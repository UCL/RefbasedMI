referindex<-which(reference==ntreat)
}
# multiple  simulations start here within the pattern loop #########
for ( m in  1:M)  {
#*FOR INDIVIDUALS WITH NO MISSING DATA COPY COMPLETE DATA INTO THE NEW DATA MATRIX mata_all_new `m' TIMES
#if `pat' == 0{
m_mg_iter<-m_mg_iter+1
# 0312 at every m we need to replace the already imputed interims estiated from fillinterims subroutune
#impMarint0[impMarint0[,'.id'] %in% test1611impD02[,'.id'], ] <- test1611impD02
# only need create these once, not every iteration/imputation, so test  if the last imputation has already been created
# because if it has then so have all the others!
if (!exists((paste0("Imp_Interims_",M)))  )  {
assign(paste0("Imp_Interims_",m),subset(as.matrix(Imp_Interims[Imp_Interims$.imp==m,])))
}
# also create 0 for use in adddelta ?
Imp_Interims_0<- subset(as.matrix(Imp_Interims[Imp_Interims$.imp==0,]))
# browser(text="0412")
# prblems wit hte matching, has to be ame cols but ordre affected so create index
# tet_mata_Obs<-mata_Obs
#  tet_mata_Obs$index<-1:nrow(tet_mata_Obs)
#  tet_mata_Obs_drop<- subset(tet_mata_Obs,select= c(.id,patt,treat,index))
#  tet_mata_Obs_x <-  subset(tet_mata_Obs,select= -c(patt,treat,index))
#save the .miss cols
#  tet_mata_Obs_miss<-tet_mata_Obs_x[,grep(".miss",colnames(tet_mata_Obs_x))]
#drop the .miss cols
#  tet_mata_Obs_x<- tet_mata_Obs_x[,-grep(".miss",colnames(tet_mata_Obs_x))]
# have have same cols in interim file
ImpInters <-    get(paste0("Imp_Interims_",m))
#     browser(text="1112") #NOTE depvar = fev in antidep data!!??r
# set treatname ,may have to do others sometime?
colnames(ImpInters)[colnames(ImpInters)==treatvar]<-"treat"
test_Imp <- subset(ImpInters,select=-c(.imp,patt,treat))
# browser(text="11121 interim for aNTIDEP data")
# the last col (id) has to be moved to the 1st!
test_Imp_r<-test_Imp[,c(ncol(test_Imp),1:(ncol(test_Imp)-1))]
# now merge Imp_Interims from m'th iteration
#mata_Obs[mata_Obs[,'.id'] %in% get(paste0("Imp_Interims_",m))[,'.id'],] <- get(paste0("Imp_Interims_",m))
## it is essential that the 2 files (have the same cols?) and in the same col order
# note setkey wil sort by key
#  mata_Obsdt2<-data.table(mata_Obs)
#  test_Impdt<-data.table(test_Imp)
#  setkey(test_Impdt,'.id')
#0812 try
# setting row seq to preserve order after merge , failng to ovewrite imp >1 values?
#       mata_Obs$index<-1:nrow(mata_Obs)
#        Result<-(merge(mata_Obs,test_Imp,all.x=T))
#        Result<-Result[order(Result$index),]
#        mata_Obs<-subset(Result,select= -c(index))
# just use as a look upi table ! so
df1<-as.data.frame(mata_Obs)
df2<-as.data.frame(test_Imp)
# repeat for all depvar cols
#0812 seems this good methd!?
#df1$fev.2[match(df2$.id,df1$.id)]<-df2$fev.2)
# find depvar vars
depcols<-setdiff( grep(paste0(depvar),names(df1)) , grep('.miss',names(df1)))
# assume thes coorespnd with interim lookup ! prob ned a check here!!
# actually faster using match than fmatch
for ( pos in 1:length(depcols)) {
df1[,depcols[pos]][match(df2$.id,df1$.id)]<-df2[,depcols[pos]]
}
mata_Obs <- df1
#browser(text="no missing values")
# if no missing values
if(length(c_mata_miss)==0 ) {
# start and end row positions
st<-mg[i,"cumcases"]-mg[i,"cases"]+1
en <-mg[i,"cumcases"]
# id (SNO) is 1st col
# either reorganise mata_Obs so id is 1st col  or use id as col name 0812
#SNO<-mata_Obs[c(st:en),1]
SNO<-mata_Obs[c(st:en),".id"]
# this doesnt delete treat
#mata_new <- mata_Obs[c(st:en),2:ncol(mata_Obs)]
mata_new<-mata_Obs[c(st:en),!(names(mata_Obs) %in% c(idvar))]
#browser() # treat defined within fun
GI <- array(data=mg[i,treatvar],dim=c(mg[i,"cases"],1))
#II  no imputations
II <- array(data=m,dim=c(mg[i,"cases"],1))
mata_new=cbind(GI,II,mata_new,SNO)
#names(mata_all_new)<-names(mata_new)
#    browser(text="0201")
mata_all_newlist[[m_mg_iter]]=mata_new
# mata_all_new=rbind(mata_all_new,mata_new)
# else if there are missing values
} else {
# need to distinguish between meth and methodindiv
if (flag_indiv==0 ) {
# browser(text="0902")
referindex<- reference
#FOR INDIVIDUALS WITH  MISSING DATA  `m' TIMES
# dependent on method chosen
# 'MAR'
#browser(text="2611")
if (method== 1)  {
# 11/11 checking methd used for interims in J2R works as MAR
#mata_means <- get(paste0("param",trtgp,m))[1]
mata_means <- paramBiglist[[M*(trtgpindex-1)+m]][1]
# mata_means<-mata_means[rep(seq(nrow(mata_means)),each=mg$X1[i]),]
# convert from list element to matrix
mata_means <- mata_means[[1]]
#Sigmatrt <- get(paste0("param",trtgp,m))[2]
Sigmatrt <- paramBiglist[[M*(trtgpindex-1)+m]][2]
S11 <-Sigmatrt[[1]][c_mata_nonmiss,c_mata_nonmiss]
#S12 <-Sigmatrt[[1]][c_mata_nonmiss,c_mata_miss]
# to ensure col pos same as stata
S12 <-matrix(Sigmatrt[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss))
S22 <-Sigmatrt[[1]][c_mata_miss,c_mata_miss]
}
# 'J2R'
else if (method == 3 ) {
# changed saving the result into  just the param file, list of 2 so can use list index here
#treatmnets are 1.. M then M+1 ..2M .. etc
mata_means_trt <- paramBiglist[[M*(trtgpindex-1)+m]][1]
mata_means_ref <- paramBiglist[[M*(referindex-1)+m]][1]
#browser(text="pass2method")
# below causes error after using >1 covars and mata_nonmiss has covar.1, not proper covar names
#    browser(text="3112")
# mata_nonmiss and mata_miss toolage in acupuncture data
# repetition of head_base ,the covariate !
mata_means_t <-lapply(mata_means_trt,FUN = function(x) x*mata_nonmiss)
#mata_means_t <- unlist(mata_means_trt)*mata_nonmiss
# print(paste0("mata_means_trt, mata_nonmiss= ",mata_means_trt,mata_miss))
mata_means_r <-lapply(mata_means_ref,FUN = function(x) x*mata_miss)
#mata_means_r <- unlist(mata_means_ref)*mata_miss
# so when all missing  1,1,1, ... then all contributing comes from reference means
mata_means <- unlist(mata_means_r)+unlist(mata_means_t)
#try this 11/04
mata_means<-(as.matrix(t(mata_means)))
# and preserve names
# 11/04 colnames(mata_means) <-  colnames(mata_means_t[[1]])
#replicate to number of rows defined by X1
#mata_means<-mata_means[rep(seq(nrow(mata_means)),each=mg$X1[i]),]
############# SIGMA is from paramsigma  the reference group ################
# do we ever  use SigmaTrt !!?? in j2r?
# answer is ??, need to use SigmaTrt for the predeviation observations, ie up to where they go missing
# only after they go missing (trailing missing) need to use the SigmaRef
#9/3/20
SigmaRefer <- paramBiglist[[M*(referindex-1)+m]][2]
#SigmaRefer <- paramBiglist[[M*(referindex-1)+m]][2]
#SigmaRefer <- get(paste0("paramBiglist",refer,m))[2]
Sigmatrt <- paramBiglist[[M*(trtgpindex-1)+m]][2]
# note use of [[1]] as is matrix rathe than list,
S11 <-SigmaRefer[[1]][c_mata_nonmiss,c_mata_nonmiss]
# causes non-def error in conds
#to ensure rows and cols as should reflect their stucture use matrix
S12 <-matrix(SigmaRefer[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss))
S22 <-SigmaRefer[[1]][c_mata_miss,c_mata_miss]
} #method
# 'CR'
else if (method==2) {
# no need to use Sigmatrt here
mata_means <- paramBiglist[[M*(referindex-1)+m]][1]
#mata_means <- get(paste0("param",refer,m))[1]
# convert from list to matrix
mata_means <- mata_means[[1]]
SigmaRefer <- paramBiglist[[M*(referindex-1)+m]][2]
S11 <-SigmaRefer[[1]][c_mata_nonmiss,c_mata_nonmiss]
S12 <-matrix(SigmaRefer[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss) )
S22 <-SigmaRefer[[1]][c_mata_miss,c_mata_miss]
#Sigma<-SigmaRefer
}
# 'CIR'
else if (method==4)
{
# need to use Sigmatrt as in j2r
# pre-deviating use mean of trt gp up to last obs time bfore deviating, post-deviating use mean from ref grp
# put equiv to mimix
#mata_Means <- get(paste0("param",trtgp,m))[1]
mata_Means <- paramBiglist[[M*(trtgpindex-1)+m]][1]
# convert from list to matrix
mata_Means <- mata_Means[[1]]
#mata_Means <-  get(paste0("parambeta",trtgp,m))
#MeansC <-  get(paste0("param",refer,m))[1]
MeansC <-  paramBiglist[[M*(referindex-1)+m]][1]
#might be better to copy mimix algol
mata_means<-CIR_loop(c_mata_miss,mata_Means,MeansC)
#returns mata_means as single row
# then duplicate over patt rows
#replicate to number of rows defined by X1
# mata_means<-mata_means[rep(seq(nrow(mata_means)),each=mg$X1[i]),]
#SigmaRefer <- get(paste0("paramsigma",refer,m))
SigmaRefer <- paramBiglist[[M*(referindex-1)+m]][2]
# when reading in Stata sigmas
S11 <-SigmaRefer[[1]][c_mata_nonmiss,c_mata_nonmiss]
S12 <-matrix(SigmaRefer[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss))
S22 <-SigmaRefer[[1]][c_mata_miss,c_mata_miss]
# Sigma<- SigmaRefer
}
# 'LMCF'
else if (method==5) {
#browser(text="0602")
#mata_Means <-  get(paste0("param",trtgp,m))[1]
mata_Means <- paramBiglist[[M*(trtgpindex-1)+m]][1]
# convert from list to matrix
mata_Means <- mata_Means[[1]]
# no ref MeansC <- mata_means_ref
mata_means<-LMCF_loop(c_mata_miss,mata_Means)
#mata_means<-mata_means[rep(seq(nrow(mata_means)),each=mg$X1[i]),]
#Sigmatrt <- get(paste0("param",trtgp,m))[2]
Sigmatrt <- paramBiglist[[M*(trtgpindex-1)+m]][2]
# when reading in Stata sigmas
S11 <-Sigmatrt[[1]][c_mata_nonmiss,c_mata_nonmiss]
S12 <-matrix(Sigmatrt[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss))
S22 <-Sigmatrt[[1]][c_mata_miss,c_mata_miss]
#   Sigma<- Sigmatrt
}  #if meth=5
# causal method uses same matrices as CIR with K parameter
else if (method==6)  {
mata_Means <- paramBiglist[[M*(trtgpindex-1)+m]][1]
# convert from list to matrix
mata_Means <- mata_Means[[1]]
#mata_Means <-  get(paste0("parambeta",trtgp,m))
#MeansC <-  get(paste0("param",refer,m))[1]
MeansC <-  paramBiglist[[M*(referindex-1)+m]][1]
#put Kd tempval
#Kd =0 eq0iv to J2R?
#Kd =1 equiv to CIR
#Kd<-0.8
#10/08/20
#browser(text="1301")
mata_means<-Causal_loop(c_mata_miss,mata_Means,MeansC,K0,K1)
#  browser()
#this temporary  for test purposes until algo decided upon
SigmaRefer <- paramBiglist[[M*(referindex-1)+m]][2]
# when reading in Stata sigmas
S11 <-SigmaRefer[[1]][c_mata_nonmiss,c_mata_nonmiss]
S12 <-matrix(SigmaRefer[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss))
S22 <-SigmaRefer[[1]][c_mata_miss,c_mata_miss]
#10/08/20
#Sigma<- SigmaRefer
}
############# individual analysis #########################
}
#else if(!is.null(methodindiv[1]))
else if (flag_indiv==1) {
# call function for  indiv
indparamlist  <- ifmethodindiv(methodvar,referencevar,mg,m,M,paramBiglist,i,treatvar,c_mata_nonmiss,c_mata_miss,mata_miss,mata_nonmiss,K0,K1)
mata_means<- indparamlist[[1]]
Sigma <- indparamlist[[2]]
}
# loop still open for row(mg)
###################### MNAR IMPUTATION ################
# need insert routine when ALL missing values
# else
###################### MNAR IMPUTATION ################
#make sure these are single row vectors! as mistake in LMCF but have to be duplicate rows so add ,s
#and move after dup fun
# need to repictae mata_means to same numbe rrows as data pattern group
# causing problems replace with simpler
mata_means<-mata_means[rep(seq_len(nrow(mata_means)),each=mg$cases[i]),]
# mata_means<- do.call("rbind",replicate(mg[i,"cases"],mata_means,simplify=FALSE))
#perhaps put zeros in ? to make sure same length??
if (!is.null(nrow(mata_means)) )  {
m1 <- mata_means[,c_mata_nonmiss]
m2 <- mata_means[,c_mata_miss]
} else {
m1 <- mata_means[c_mata_nonmiss]
m2 <- mata_means[c_mata_miss]
}
#then mata_obs is the sequential selection of rows according to the mimix_group variable X1 values
#need a counter to accumulate j  - easiest way is to ceate a cumulstive col in mimix_group
j <- mg[i,"cases"]
#for debug
#print(paste0(" count in patt = ", j))
k <- mg[i,"cumcases"]
startrow <-(k-j+1)
stoprow  <-(k)
#raw1 <- mata_obs[, c_mata_nonmiss]
# preraw <- mata_Obs[c(startrow:stoprow),2:ncol(mata_Obs)]
# drop id  cols from raw data
preraw <-(mata_Obs[c(startrow:stoprow),!(names(mata_Obs) %in% c(idvar))])
raw1 <- preraw[,c_mata_nonmiss]
##### try inserting routine for all missing values here NOt really necessary!! ### 20/1/20 #####
## when all missing data, the length of c_mata_nonmiss must exclude the no. of covariates
## temporary fix set as 1, ie no. of covars 20/01/20
# nOTE think no observed data includes no base line as well?
# all missing ? didnt think we did ths scenario, ie base depvar always complete?
if (length(c_mata_nonmiss)==0)  {
## routine copied from mimix line 1229
# change 9/5/20 becaus error list obj cannot be coerced to double
#0401 U <- chol(Sigma[[1]])
# replaced this with S22 because S11 S12 have 0 values when so try
U <- chol(S22)
# generate inverse normal, same as used below
#for debug 20/01
#   print(paste0('mg[i,X1] =',mg[i,"X1"],' miss_count= ',miss_count))
miss_count<-sum(mata_miss)
Z <- stats::qnorm(matrix(stats::runif( mg[i,"cases"]* miss_count,0,1),mg[i,"cases"],miss_count))
# raw and m1 null fields so hut use m2
meanval = as.matrix(m2)
mata_y1 = meanval+Z%*%(U)
#set dimensions mata_new to mata_y1
#define new matrix from observed,  id column  (the last)
mata_new <- preraw
# mata_new has to be already defined
mata_new[,c_mata_miss] <- (mata_y1)
GI <- array(data=mg[i,treatvar],dim=c(mg[i,"cases"],1))
#II  no imputations
II <- array(data=m,dim=c(mg[i,"cases"],1))
# SNO just id col
# change 1012
#SNO <- mata_Obs[c(startrow:stoprow),1]
SNO <- mata_Obs[c(startrow:stoprow),".id"]
mata_new=cbind(GI,II,mata_new,SNO)
mata_all_newlist[[m_mg_iter]]=mata_new
# 9/5/20 inser else here
} else {
#so S12 must be declare as a matrix ! as number otherwise is class number
#try transpose as was failing compatible error
#note y must have same no rows as Q
#solve Qx=y
#t_mimix =cholsolve(Q=mS11,y=(mS12))
#tryig solve instead ax=b
t_mimix=solve(S11,S12)
conds <-  S22-t(S12)%*%t_mimix
#
#meanval = as.matrix(m2) + as.matrix(raw1 - m1)%*%as.matrix(t_mimix)
# below for CR but need checks work with J2R
# need edit m2 as errormsg "data frame with 0 columns and 1 row"
# 9/3/20
#browser() the else condition not works ,m2 needs matrix
## important calculation to CHECK !!!
#depends whether meth or methodindiv used
#really this needs to be independent of which merh used
# if (meth=='J2R')
#  if  (mg[i,methodindiv[1]] == 3) {
#{  1*1 MATRIX ?
# } else if (mg[i,methodindiv[1]] == 4)   {
# m2 careful as matrix needs to be vertical , test change 17/03
# this works for accupuncture data but not asthma, because when one patient raw daa is 1 by n matrix so m2 needs to be horizontal, ie not a matrix
#19/03  11/04 works for CR but then not for J2R for 5333 patt=7 one patient
if (mg[i,"cases"] == 1) {
meanval = (m2) + as.matrix(raw1 - m1)%*%as.matrix(t_mimix)
}  else {
meanval = as.matrix(m2) + (as.matrix(raw1 - m1)%*%as.matrix(t_mimix))
}
#24/02browser()
U <- chol(conds)
# mg[i,cases] is equiv to Stata counter, miss_count is no. of missing, so
miss_count=rowSums(mata_miss)
# gen erate inverse normal
Z<-stats::qnorm(matrix(stats::runif( mg[i,"cases"]* miss_count,0,1),mg[i,"cases"],miss_count))
# check same input parameters for inverse norm gen as in stata
#for debug 20/01
#  print(paste0('mg[i,X1] =',mg[i,"X1"],' miss_count= ',miss_count))
#mata_y1 = meanval+Z%*%t(U)  14/01/20 try without transpose because Stata Cholesky lower tri, R upper (or vice versa)
mata_y1 = meanval+Z%*%(U)
#define new matrix from observed,  id column  (the last)
mata_new <- preraw
# assigning the columns where the missing values
# was nct (as in stata) = no ntimes + ncovar
# so if no missing then just copy full values into mata_new columns
#if(length(c_mata_miss)==0 ) { mata_new[,c(1:length(tst2))] <- mata_Obs[,c(2:length(tst2))]
if(length(c_mata_miss)==0 ) { mata_new[,c(1:length(tst2))] <- preraw[,c(1:length(tst2))]
}else
{
mata_new[,c_mata_miss] <- mata_y1
}
# if(length(c_mata_miss)!=0 )
#save U,Z for imp(m) and patt(i)
# this worked for Z
#assuming this  from Stata if "`interim'"==""{
# SNO just id col
# chg 1012SNO <- mata_Obs[c(startrow:stoprow),1]
SNO <- mata_Obs[c(startrow:stoprow),".id"]
#SNO <- mata_ObsX[,ncol(mata_Obs)]
# GI treatment grp column 1 (here),II imputation number col, mata_new matrix then SNO is id col.
GI <- array(data=mg[i,1],dim=c(mg[i,"cases"],1))
#II  no imputations
II <- array(data=m,dim=c(mg[i,"cases"],1))
#doesnt need SNO, as id already in
#mata_new<-cbind(GI,II,mata_new,SNO)
#this works but bette to pre initialise data structure outsidr loop
mata_new<-cbind(GI,II,mata_new,SNO)
#assume delta to be used if specified in input argument
if (length(delta != 0) ) {
# browser()
# reset ncovar_i and create dlag if null] browser(text="1612")
# browser(text="1712")
ncovar_i<-length(covar)
if (is.null(dlag)) {
dlag <- rep(1,length(delta))
}
mata_new <-  AddDelta(tst2,  ncovar_i,mata_new,delta,dlag)
# mata_new <-  AddDelta(tst2,  ncovar_i,mata_new,delta,dlag,Imp_Interims_0)
}
mata_all_newlist[[m_mg_iter]]=mata_new
#mata_all_new<-rbind(mata_all_new,mata_new)
#mata_all_new<- na.omit(mata_all_new)
#stata equilv \ is row bind NOt cbind!!?
#9/5/20 end else c_mata_nonmiss ==0 here
}
} # ( m in  1:M) so insert delta module just before this
} #for row[mg]
# check for interim 11/11
# browser()
} #for M StOP HERE!!
# browser(text="passtoloop")
#browser(text="1801")
impdataset<-getimpdatasets(list(mata_all_newlist,mg,M,method))
# but need to adjust orig data set to set interims back to missing
# get .imp=0 's
assign(paste0("Imp_Interims_",0),subset(as.matrix(Imp_Interims[Imp_Interims$.imp==0,])))
# find depvar vars  cols
ImpInters <-    get(paste0("Imp_Interims_",0))
# note keep .imp so can use as match with impdaset and also presreve same col pos
# browser(text="1112 treat? ")
colnames(ImpInters)[colnames(ImpInters)==treatvar]<-"treat"
test_Imp <- subset(ImpInters,select=-c(patt,treat))
#df1<-as.data.frame(mata_Obs)
test_Imp<-as.data.frame(test_Imp)
depcolsf<- grep(paste0(depvar),names(impdataset))
# assume thes coorespnd with interim lookup ! prob ned a check here!!
for ( pos in 1:length(depcolsf)) {
#if (impdataset$.imp==0 )
#impdataset[,depcolsf[pos]][match(test_Imp$.id,impdataset$.id)]<-test_Imp[,depcolsf[pos]]
impdataset[,depcolsf[pos]][match(paste(test_Imp$.id,test_Imp$.imp),paste(impdataset$.id,impdataset$.imp))]<-test_Imp[,depcolsf[pos]]
}
# moved from getimpdatasets fun
cat(paste0("\n\nNumber of final missing values = ", sum(is.na(subset(impdataset,impdataset$.imp>0)))))
#cat(paste("\ntest pass2 in runmimx"))
return(impdataset)
}
#' @title fills missing interims distinguishing from post-discontinuation
#' @description fills missing interims distinguishing from post-discontinuation
#' @details checks methodindiv not null
#' @param impdata the data with missing values
#' @param interims the interim cases with estimated MAR values
#' @param Mimp the number of imputations specified , ie M total imputsations
#' @return list of 1st data set with interims imputed plus M interim cases of each interim case to be matche in 2nd pass
fillinterims<- function(impdata,interims,Mimp=M ) {
#2811
#0312 browser(text="not means")
#2711browser(text="find estimate over all imps")
#convert to data.table
#2611 browser(text="fillinterims")
impMarint_dt <- data.table::as.data.table(impdata)
interims_dt <- data.table::as.data.table(interims)
#browser(text="2402")
data.table::setkey(impMarint_dt,.id)
data.table::setkey(interims_dt,V1)
#merge
#(impMarint_dt[interims_dt])
# convert to 0, 1 =missing
# sapply(impMarint_dt[interims_dt],function(x) ifelse(is.na(x) ,1,0) )
# exclude last non-response cols
test10<-sapply(impMarint_dt[interims_dt],function(x) ifelse(is.na(x) ,1,0) )
test10x<-test10[,c(1:(ncol(test10)-3))]
# find max non-missing
lastvalid<-apply(test10x,1, function(x) max(which(x==0))  )
#merge back
test1611<-cbind(impMarint_dt[interims_dt],lastvalid)
#if (test1611$.id == shift(test1611$.id,-1) ) {
# over many imps, find mean value by interims for imp>0 then combineback to
# have .imp0 and mean row
# 2811 no need for means now just need to send  M'th values of fev 2-fev12
#test2611 <-setDT(as.data.frame(subset(test1611,.imp>0)))[,lapply(.SD,mean),by= .id,]
#2911 test2611 <- setDT(as.data.frame(subset(test1611,.imp>0)))[,lapply(.SD,mean),by= .(id,imp)]
# find.imp0's  test3611[order(test3611$.id),][order(assign(paste0("test1611imp",val),subset(test1611,.imp==val))$.id),]
test1611imp0<- subset(test1611,.imp==0)
#declare void matrix for rbinding
test1611impD <- test1611imp0
for (val in 1:Mimp) {
rbind(assign(paste0("test1611imp",val),subset(test1611,.imp==val | .imp==0)),test1611imp0)
test1611impx<-as.matrix(get(paste0("test1611imp",val )))
for  (r in seq(from =1 , to= nrow(test1611impx)-1,by=2)) {
for (j in 2:(ncol(test1611impx)-3)) {
# if element na and must be bfore lastvalid non missing
if (is.na(test1611impx[r,j]) & (j<test1611impx[r,ncol(test1611impx)]) ) {
# then shift value from below row
test1611impx[r,j] = test1611impx[r+1,j]
}
}
}
# keep imp0's and recode non imp0 to imp (m) number
test1611impxm <-  subset(test1611impx,test1611impx[,".imp"]==0)
test1611impxm[,".imp"]<-val
# build up ovder M imps
test1611impD <- rbind(test1611impD,test1611impxm)
}
# so need to insert into original unimputed data set for each imputstion and process each dat set into the 2nd pass
# take lastvalid off
#test1611impDl<-test1611impD[,-ncol(test1611impD)]
test1611impD$lastvalid <-NULL
#extract m'th imp
test1611impD02<-as.matrix(test1611impD[test1611impD$.imp==2,])
#test1611impD02<-as.matrix(test1611impDl[test1611impDl[,1]==2,])
impMarint <- as.matrix(impMarint_dt)
impMarint0<-as.matrix(impMarint_dt[impMarint_dt$.imp==0,])
# this works well (but MUST Be MATRICES)
#212 impMarint0[impMarint0[,'.id'] %in% test1611impD02[,'.id'], ] <- test1611impD02
# so .imp=0 now has interims filled and can be treated as original data
return(list(impMarint0,test1611impD))
}
# mimix: A package porting the Stata mimix command
#
# The mimix package provides the functionality of the Stata package plus
# delta and causal methods
#
# @section Comparison with Stata:
# details here ...
#
# @section Comparison with SAS:
# details here ...
#
#
# @docType package
# @name mimix
#NULL
#> NULL
mimix("asthma",c("base"),"fev","treat","id","time",5,1,"J2R",,,,,,,,,1,0.5,)
