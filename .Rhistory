m2 <- mata_means[c_mata_miss]
}
#then mata_obs is the sequential selection of rows according to the mimix_group variable X1 values
#need a counter to accumulate j  - easiest way is to ceate a cumulstive col in mimix_group
j <- mg[i,"cases"]
#for debug
#print(paste0(" count in patt = ", j))
k <- mg[i,"cumcases"]
startrow <-(k-j+1)
stoprow  <-(k)
#raw1 <- mata_obs[, c_mata_nonmiss]
# preraw <- mata_Obs[c(startrow:stoprow),2:ncol(mata_Obs)]
# drop id  cols from raw data
preraw <-(mata_Obs[c(startrow:stoprow),!(names(mata_Obs) %in% c(idvar))])
raw1 <- preraw[,c_mata_nonmiss]
##### try inserting routine for all missing values here NOt really necessary!! ### 20/1/20 #####
## when all missing data, the length of c_mata_nonmiss must exclude the no. of covariates
## temporary fix set as 1, ie no. of covars 20/01/20
# nOTE think no observed data includes no base line as well?
# all missing ? didnt think we did ths scenario, ie base depvar always complete?
if (length(c_mata_nonmiss)==0)  {
## routine copied from mimix line 1229
# change 9/5/20 becaus error list obj cannot be coerced to double
U <- chol(Sigma[[1]])
# generate inverse normal, same as used below
#for debug 20/01
#   print(paste0('mg[i,X1] =',mg[i,"X1"],' miss_count= ',miss_count))
miss_count<-sum(mata_miss)
Z <- stats::qnorm(matrix(stats::runif( mg[i,"cases"]* miss_count,0,1),mg[i,"cases"],miss_count))
# raw and m1 null fields so hut use m2
meanval = as.matrix(m2)
mata_y1 = meanval+Z%*%(U)
#set dimensions mata_new to mata_y1
#define new matrix from observed,  id column  (the last)
mata_new <- preraw
# mata_new has to be already defined
mata_new[,c_mata_miss] <- (mata_y1)
GI <- array(data=mg[i,treatvar],dim=c(mg[i,"cases"],1))
#II  no imputations
II <- array(data=m,dim=c(mg[i,"cases"],1))
# SNO just id col
SNO <- mata_Obs[c(startrow:stoprow),1]
mata_new=cbind(GI,II,mata_new,SNO)
mata_all_newlist[[m_mg_iter]]=mata_new
# 9/5/20 inser else here
} else {
#so S12 must be declare as a matrix ! as number otherwise is class number
#try transpose as was failing compatible error
#note y must have same no rows as Q
#solve Qx=y
#t_mimix =cholsolve(Q=mS11,y=(mS12))
#tryig solve instead ax=b
t_mimix=solve(S11,S12)
conds <-  S22-t(S12)%*%t_mimix
#
#meanval = as.matrix(m2) + as.matrix(raw1 - m1)%*%as.matrix(t_mimix)
# below for CR but need checks work with J2R
# need edit m2 as errormsg "data frame with 0 columns and 1 row"
# 9/3/20
#browser() the else condition not works ,m2 needs matrix
## important calculation to CHECK !!!
#depends whether meth or methodindiv used
#really this needs to be independent of which merh used
# if (meth=='J2R')
#  if  (mg[i,methodindiv[1]] == 3) {
#{  1*1 MATRIX ?
# } else if (mg[i,methodindiv[1]] == 4)   {
# m2 careful as matrix needs to be vertical , test change 17/03
# this works for accupuncture data but not asthma, because when one patient raw daa is 1 by n matrix so m2 needs to be horizontal, ie not a matrix
#19/03  11/04 works for CR but then not for J2R for 5333 patt=7 one patient
if (mg[i,"cases"] == 1) {
meanval = (m2) + as.matrix(raw1 - m1)%*%as.matrix(t_mimix)
}  else {
meanval = as.matrix(m2) + (as.matrix(raw1 - m1)%*%as.matrix(t_mimix))
}
#24/02browser()
U <- chol(conds)
# mg[i,cases] is equiv to Stata counter, miss_count is no. of missing, so
miss_count=rowSums(mata_miss)
# gen erate inverse normal
Z<-stats::qnorm(matrix(stats::runif( mg[i,"cases"]* miss_count,0,1),mg[i,"cases"],miss_count))
# check same input parameters for inverse norm gen as in stata
#for debug 20/01
#  print(paste0('mg[i,X1] =',mg[i,"X1"],' miss_count= ',miss_count))
#mata_y1 = meanval+Z%*%t(U)  14/01/20 try without transpose because Stata Cholesky lower tri, R upper (or vice versa)
mata_y1 = meanval+Z%*%(U)
#define new matrix from observed,  id column  (the last)
mata_new <- preraw
# assigning the columns where the missing values
# was nct (as in stata) = no ntimes + ncovar
# so if no missing then just copy full values into mata_new columns
#if(length(c_mata_miss)==0 ) { mata_new[,c(1:length(tst2))] <- mata_Obs[,c(2:length(tst2))]
if(length(c_mata_miss)==0 ) { mata_new[,c(1:length(tst2))] <- preraw[,c(1:length(tst2))]
}else
{
mata_new[,c_mata_miss] <- mata_y1
}
# if(length(c_mata_miss)!=0 )
#save U,Z for imp(m) and patt(i)
# this worked for Z
#assuming this  from Stata if "`interim'"==""{
# SNO just id col
SNO <- mata_Obs[c(startrow:stoprow),1]
#SNO <- mata_ObsX[,ncol(mata_Obs)]
# GI treatment grp column 1 (here),II imputation number col, mata_new matrix then SNO is id col.
GI <- array(data=mg[i,1],dim=c(mg[i,"cases"],1))
#II  no imputations
II <- array(data=m,dim=c(mg[i,"cases"],1))
#doesnt need SNO, as id already in
#mata_new<-cbind(GI,II,mata_new,SNO)
#this works but bette to pre initialise data structure outsidr loop
mata_new<-cbind(GI,II,mata_new,SNO)
#assume delta to be used if specified in input argument
if (length(delta != 0) ) {
# browser()
mata_new <-  AddDelta(tst2,  ncovar_i,mata_new,delta,dlag)
}
mata_all_newlist[[m_mg_iter]]=mata_new
#mata_all_new<-rbind(mata_all_new,mata_new)
#mata_all_new<- na.omit(mata_all_new)
#stata equilv \ is row bind NOt cbind!!?
#9/5/20 end else c_mata_nonmiss ==0 here
}
} # ( m in  1:M) so insert delta module just before this
} #for row[mg]
} #for M StOP HERE!!
# 23/03 addon to save as implist
#  browser()
#  dimlist <- (nrow(mg[[1]])*M)
# extract from nested list
# combine into data set containing M imputed datasets
#  mata_all_newData1x <- do.call(rbind,mata_all_newlist[[1]])
# then sort (by imputation and patient id) into M data sets and split into M lists
#  impdatasets <- mata_all_newData1x[order(mata_all_newData1x$II,mata_all_newData1x$SNO),]
#  impdatasets2 <- mata_all_newlist[order(mata_all_newlist$II,mata_all_newlist$SNO),]
impdataset<-getimpdatasets(list(mata_all_newlist,mg,M,method))
# if regression requested
#If (regress = TRUE) {
#     impdatamids <- as.mids(impdataset,  .id="SNO",.imp="II")
#     fit<-with(data= impdatamids, expr = lm(impdatamids[,length(mpdatamids)-4]~impdatamids[,treatvar])
#     paste0(summary(pool(fit)))
#}
#return(list(mata_all_newlist,mg,M,meth))
return(impdataset)
} # for mimix test
#' @title getimpdatasets
#' @description to obtain the M imputed data set from the output list into one dataset
#' @details This combines the imputations found from the M pattern groups
#' @param varlist  list of data containing imputed values from the M pattern groups
#' @return impdataset
getimpdatasets <- function(varlist){
#9/5/20
#browser()
# to obtain M imputed data sets
# dimension of data set, nrows in pattern times no imputations,
# note sub data sets wi have different cols if completely missing so
mata_all_newlist<-  varlist[1]
mg<-(varlist[2])
M<- unlist(varlist[3])
method<- unlist(varlist[4])
#dimlist <- (nrow(mg[[1]])*M)
# extract from nested list
# combine into data set containing M imputed datasets
mata_all_newData1x <- do.call(rbind,mata_all_newlist[[1]])
# then sort (by imputation and patient id) into M data sets and split into M lists
impdatasets <- mata_all_newData1x[order(mata_all_newData1x$II,mata_all_newData1x$SNO),]
#############################################
# now recreate orig data set by selecting 1st imputed data set and setting NAs using .miss dummies
imp1st<-impdatasets[impdatasets$II=="1",]
col_miss<-(imp1st[,grepl(".miss",colnames(imp1st))])
# get header of missing
hd_miss <- colnames(imp1st[,grepl(".miss",colnames(imp1st))])
# strp .miss to gt orig vars names
hd_new <- gsub(pattern=".miss",replacement = "", hd_miss)
# converting the 1's in .miss columns to NAs then
# replace dummy 0,1 by 0,na
imp1st_NA <- apply(col_miss, MARGIN =2, function(x) ifelse(x==1,NA,x) )
#assign  0 imputation number to unimputed dataset
imp1st$II <-0
# overwrite .miss cols with 0,NA  instead of 0,1
imp1st[,hd_new]<-(imp1st[,hd_new] +imp1st_NA)
# now combine recreated original with impute data
impdatasetsmiss<-rbind(imp1st,impdatasets)
# no reason to keep the dummies
# and they cause a warning on setting  as.mids() function
impdatasets <- impdatasetsmiss[,-grep(".miss",colnames(impdatasetsmiss))]
#impdatasets <- as.mids(tmpdatasets, .id="SNO",.imp="II")
# change II, SNo to be consistent with mids format
names( impdatasets)[names(impdatasets)=="II"]<-".imp"
names( impdatasets)[names(impdatasets)=="SNO"]<-".id"
# change row names to e sequential
rownames(impdatasets)<-NULL
#drop GI
impdatasets$GI <-NULL
# report and check number na's
cat(paste0("\n\nnumber of original na values = ", sum(is.na(subset(impdatasets,impdatasets$.imp==0)))))
cat(paste0("\nnumber of final na values = ", sum(is.na(subset(impdatasets,impdatasets$.imp>0)))))
#browser()
if (sum(is.na(subset(impdatasets,impdatasets$.imp>0))) !=0 ) { cat(paste0("\nWARNING! unimputed data values")) }
return(impdatasets)
}
#' mimix: A package for Reference-based imputation for longitudinal clinical trials with protocol deviation
#'
#' similar to the Stata mimix function
#'
#' The mimix package contains the functions preprodata and preproIndivdata to
#'  process long longitudinal data into wide data format
#'
#'  Also the function Addelta to add delta adjustment to the imputed estimates
#' @docType package
#' @name mimix
NULL
# so no almost reday for mice!
#fit<-with(data= as.mids(impanticausalun, .id="SNO",.imp="II"), expr = lm(HAMD17.TOTAL.7~TREATMENT.NAME+basval+POOLED.INVESTIGATOR+PATIENT.SEX))
#summary(pool(fit))
#convert to mids object (in mice package)
#impdatamids<-as.mids(impdatasets)
#impdatamids$method[IndivDtmids$method %in% "pmm"] <- "mimix"
#impdatamids$predictorMatrix<-"N/A"
# to install if not already installed
#if(!require(norm2)) install.packages('norm2')
#if(!require(mice)) install.packages('mice')
#for select  function
#install.packages("dplyr")
#library(dplyr)
# for pivot_wider function
#install.packages("tidyr")
#library("tidyr")
# for emNorm
#install.packages("norm2")
#library(norm2)
# for cholsolve
#install.packages("sparseinv")
#library(sparseinv)
#  for analysis (stat.desc)
#install.packages("pastecs")
#library(pastecs)
# for Amelia
#install.packages("amelia")
#library(amelia)
#' @title LMCF_loop
#' @description process LMCF method
#' @details This is based on Suzie Cro's Stata program
#' @param c_mata_miss vector of col locaton of missing values , eg 5 6
#' @param mata_Means vector of means after mcmc draws eg 17 1 16.8 15.5 14.6 13.2
#' @return mata_means
LMCF_loop <- function(c_mata_miss,mata_Means)
{
miss_count <- length(c_mata_miss)
mata_means <- mata_Means
for (b in 1:miss_count)  {
if (c_mata_miss[b] > 1) {
mata_means[c_mata_miss[b]] <- mata_means[(c_mata_miss[b]-1)]
}
}
return(mata_means)
}
#' @title CIR_loop
#' @description process CIR method
#' @details This is based on Suzie Cro's Stata program
#' @param c_mata_miss vector of col locaton of missing values , eg 5 6
#' @param mata_Means vector of means after mcmc draws eg 17 1 16.8 15.5 14.6 13.2
#' @param MeansC vector of means after mcmc draws using variance from reference group
#' @return mata_means
CIR_loop <- function(c_mata_miss,mata_Means,MeansC)
# mata_S_miss something like [2 3 4] ,so is cc
{
# browser()
miss_count <- length(c_mata_miss)
mata_means <- as.data.frame(mata_Means)
for (b in 1:miss_count)  {
# if 1st col missing then no value before so need to check for that
# note mimix counter just no rows in each patt
# so main looping is over missin fields, ie miss_count
# if 1st col must be ref
if (c_mata_miss[b] ==1) {
#print will cause objectto return
#print(paste0(miss_count))
#for each patt_count (from mimix_group)
#test purposes
#count<-2
# MeansC is list so use [[1]]
mata_means[b] <- MeansC[[1]][b]
} else  {
#filling in column at a time
mata_means[c_mata_miss[b]] = mata_means[(c_mata_miss[b]-1)]+ MeansC[[1]][(c_mata_miss[b])]- MeansC[[1]][(c_mata_miss[b])-1]
}
}
return(mata_means)
}
#' @title Causal_loop
#' @description process Causal method
#' @details This is based on "White,Royes,Best" paper
#' @param c_mata_miss vector of col locaton of missing values , eg 5 6
#' @param mata_Means vector of means after mcmc draws eg 17 1 16.8 15.5 14.6 13.2
#' @param MeansC vector of means after mcmc draws using variance from reference group
#' @param K0 Causal constant for use with Causal method
#' @param K1 exponential decaying Causal constant for use with Causal method  0<k1<1
#' @return mata_means
Causal_loop<- function(c_mata_miss,mata_Means,MeansC,K0,K1)
{
miss_count <- length(c_mata_miss)
mata_means <- as.data.frame(mata_Means)
for (b in 1:miss_count)  {
# if 1st col missing then no value before so need to check for that
# note mimix counter just no rows in each patt
# so main looping is over missin fields, ie miss_count
# if 1st col must be refn
if (c_mata_miss[b] ==1) {
#print will cause objectto return
#print(paste0(miss_count))
#for each patt_count (from mimix_group)
#test purposes
#count<-2
# MeansC is list so use [[1]]
mata_means[b] <- MeansC[[1]][b]
} else  {
#filling in column at a time
# mata_means[c_mata_miss[b]] = mata_means[(c_mata_miss[b]-1)]+ Kd*( MeansC[[1]][(c_mata_miss[b])]- MeansC[[1]][(c_mata_miss[b])-1])
# assuming  mata_means[t]- MeansC[[1]][t] is depature from overall mean , ie MyCov in sas macro
# find time of discontinuation (ignoring interim cases?)
# establish time of last visit ( asunming no interims for now!)
# eg c_mata_miss = (2,3,4) shows missing cols
#lastvisit is time t in Ian's paper
lastvisit <-min(c_mata_miss)-1
# departure from overall mean at time t (lastvist) , active mean - ref mean at last visit
ActRef_diff <-mata_means[lastvisit]-MeansC[[1]][lastvisit]
# 1/5/20 need to compere v CIR , J2R and doesnt use terms in  formula 7
# this was eqn 5 soln   2/6/20
#mata_means[c_mata_miss[b]] <- MeansC[[1]][c_mata_miss[b]]+  ( Kd*ActRef_diff )
#mata_means[c_mata_miss[b]] <-   *(mata_means[(c_mata_miss[b]-1)]- MeansC[[1]][(c_mata_miss[b])-1]) + (mata_means[(c_mata_miss[b])]-MeansC[[1]][(c_mata_miss[b])])
# try eq 6 Above ok! so dont interfere
# to implement eq 6 need calc current vist - lastvisit and use it to exponentiate
# the unit visit  diferences are  c_mata_miss[b]-lastvisit
# 2/6/20 eqn7 but specify k0,k1
#   mata_means[c_mata_miss[b]] <- MeansC[[1]][c_mata_miss[b]]+( K0*(K1^(c_mata_miss[b]-lastvisit))*ActRef_diff )
# try Ians  formula from emsil
# reference mean MeansC[[1]][c_mata_miss[b]] at time u
# active mean time t  (t lastvist)  mata_means[lastvisit)]
# refernce mean time t (t lasvist)
#  browser()
#18/06
v_u=as.numeric(sub('.*\\.','',colnames(mata_means[c_mata_miss]))[b])
# test whether index lastvisit has a "*.number" format (ie whether base covariate)
#if (grep('.*\\.','',colnames(mata_means[lastvisit]))==0L  )
if (suppressWarnings(is.na(as.numeric(sub('.*\\.','',colnames(mata_means[lastvisit])))))) {
v_t<-0
}
else
{
v_t <-  as.numeric(sub('.*\\.','',colnames(mata_means[lastvisit])))
}
mata_means[c_mata_miss[b]] <- MeansC[[1]][c_mata_miss[b]]+K0*(K1^(v_u-v_t))*(mata_means[lastvisit]-MeansC[[1]][lastvisit])
}
}
return(mata_means)
}
#' @title regressimp
#' @description run regression on M imputed data set, combining as Rubin's rules
#' @details This is approach followed from  norm2 user manual
#' @export regressimp
#' @param dataf data-frame
#' @param regmodel regression model specfication
#' @return estimates of regression coefficients
#' @examples
#' \dontrun{
#' regressimp(impdataset,"fev.12~treat+base")
#' }
regressimp <- function(dataf,regmodel)  {
# to get the list
implist1x <- split(dataf,dataf[,"II"])
# so has M elements in list
# can obtain a list of coefficients and their se's from a regression
# declare list for estimates
est.list <- as.list(NULL)
# declare lists for se's
std.err.list <- as.list( NULL )
M<- utils::tail(dataf[,"II"],1)
for( m in 1:M ){
#mod<-lm(fev12~as.factor(treat)+base,data=kmlist1x[[m]] )
#mod<-lm(head12~head_base+sex,data=implist1x[[m]] )
#mod<-lm(HAMD17.TOTAL7~basval+HAMD17.TOTAL6,data=implist1x[[m]] )
mod<-stats::lm(regmodel,data=implist1x[[m]] )
est.list[[m]] <- stats::coef(summary(mod))[,1]
std.err.list[[m]] <- stats::coef(summary(mod))[,2]
}
## combine the results by rules of Barnard and Rubin (1999)
## with df.complete = 27, because a paired t-test in a dataset with
## N=28 cases has 27 degrees of freedom
miResult <- norm2::miInference(est.list, std.err.list, df.complete=801)
print(miResult)
# trying mcerror
#return(list(est.list,std.err.list))
}
#' @title analyselist
#' @description find descriptive stats on the  M imputed data set
#' @details select on patient id and find their means etc
#' @export analyselist
#' @param id patient identifier
#' @param datlist imputed dataset of M imputations
#' @param varlist list of derived variables ,varlist <- c("fev.2","fev.4","fev.8","fev.12","base")
#' @return printout of descriptve stats
#' @examples
#' \dontrun{
#' varlist <- c("fev.2","fev.4","fev.8","fev.12","base")
#' analyselist(5099,impdataset,varlist)
#' }
analyselist <-function(id,datlist,varlist) {
datano <- subset(datlist,id==datlist$.id)
# numbers denote the descriptive stats to display
t(round(pastecs::stat.desc(datano)[,varlist],3)[c(1,9,13,4,8,5),])
}
#' @title AddDelta
#' @description add delta's to imputed values
#' @details Adding delta values after wthdrawal.
#' Specifying delta and dlag allows imputations to differ sytematically from RBI methods.
#' They provide an increment which is added on to all values imputed after
#' treatment discontinuation, but not to interim missing values. Values of delta are cumulated after treatment
#' discontinuation. For example, for an individual who  discontinued treatment at the 2nd time point, we take
#' the vector of delta's starting at the 3rd time point and add their cumulative sums to the imputed values.
#' Specifying dlag modifies this behaviour, so that the vector of delta's starting at the 3rd time point is
#' multipled elementwise by the vector dlag. The formula for the increment at time k for an individual who
#' discontinued after time p is b_1*a_{p+1} + b_2*a_{p+2} + ... + b_{k-p}*a_k where delta=(a_1,a_2,...) and
#' dlag=(b_1,b_2,...). A common increment of 3 at all time points after treatment discontinuation is achieved
#' by delta=c(3,3,3,...) and dlag=c(1,0,0,...)."
#' @param vec_tst  vector of visit names
#' @param ncovar number covariates
#' @param mata_imp the imputed values (as well as the complete)
#' @param delta vector of delta values (a values in Roger's) for each vist time
#' @param dlag vector of dlag values (b values in Roger's) for each vist time
#' @return mata_imp the adjusted imputed vaues (and unadjusted non-missing)
AddDelta<-function(vec_tst,ncovar,mata_imp,delta,dlag)  {
#browser()
# need read dlag in mimix argument, so temp here
# if dlag = NULL create vector of 1's...
# create vector of 1 and 0s
#browser()  no space before .miss 12/5/20, stat at 3rd col skipping GI II
#onezero<-sapply(vec_tst[3:(2+length(vec_tst)-ncovar)], function(x) return(mata_imp[1,paste0(x,".miss")]))
onezero<- sapply(vec_tst, function(x) return(mata_imp[1,paste0(x,".miss")]))
#drop covariates (which should be complete anyway)
dropcovar <- ncovar+1
onezero<-onezero[c(dropcovar:length(onezero))]
# then 1st and last  ,set last0 as last of complete  before the missing values start
# but as to go in if because min(0,0,..) cause warnings
#lastVisit <- min(which(unlist(onezero)==1))
# check not interim , ie no gaps in onezero seq
# in which case just leave wout delta adjustment but print warnnig msg
# determine whether interim by noting if a zero appears after any one,
# ie if 1st occurence of 1 to left of any 0
#browser() 16/06/20
#set lastvisit before discontinuation
lastvisit <- max(which(unlist(onezero)==0))
# check whether any missing after this
if (lastvisit >  max(which(unlist(onezero)==1)))
{
#if (max(which(unlist(onezero)==0)) >  min(which(unlist(onezero)==1))) {
# do nothing as no discontinutions
}
else
#do for discontinuations
{
# if length = max then no gaps
# if all 0's the no missing so no adjustment required
#if (sum(which(unlist(onezero)!=0) ) ) {
# check no gaps, ie interims, not quite right!
#if ( length(which(unlist(onezero)==1)) == max(which(unlist(onezero)==1)) ){
#  lastVisit <- min(which(unlist(onezero)==1)) }
# want to ignore interims but not discontinuations  so
# the max position of non-missing is where the missing needs to start +1 so not this
#lastvisit <- min(which(unlist(onezero)==1))-1
# lastvisit <- max(which(unlist(onezero)==0))
# so add appropriate delta to imputed values after last visit
#lastvisit is p in JamesRogers paper
super_delta<-0
v<-0
# for (v in lastVisit:length(onezero)) {
# when dlag used super_delta<- super_delta + delta[v]* dlag[v-1]
# we only increment delta when missing, so skip if non imssing
# 1st row should be same value for all rows in the same pattern group, gives warning othewise
# range of values to be changed in mata_imp given by the cols start:end
start<- 2+ncovar+1
end <- 2+length(vec_tst)
#mata_imp[,start:end]
#loop ove selected range in mata_imp
for (j in (start+lastvisit):end) {
#4:8
#if (mata_imp[1,start+v]==1) {
# adjust from last visit (ignore interims for now)
#for (v in lastVisit:length(onezero)) {
# count from start to end
v<- v+1
super_delta <- super_delta + delta[j-start+1]*dlag[v]
mata_imp[j] <- mata_imp[j] + super_delta
}
#browser()
# mata_new values start in col 3 so must add 2 to index
# needs adjusting for when interim case non missing! test dummy missing vars
# jump<-length(vec_tst)
# mata_imp[2+v]<- ifelse(mata_imp[2+v+1+jump]==1,mata_imp[2+v] + super_delta,mata_imp[2+v])
#{
#print(paste0("interim missing, check delta adjustment ",onezero))
# mata_imp[2+v] <- mata_imp[2+v] + super_delta
}   #if not interim
# need report after final call
if (sum(is.na(mata_imp)) !=0 ) { cat(paste0("\nWARNING!!! unimputed data values, possibly due to mis-specified delta")) }
#cat(paste0("\nnumber of final na values = ", sum(is.na(subset(mata_imp,mata_imp$II>0)))))
return(mata_imp)
}
devtools::document()
library(devtools)
install_github("UCL/mimix")
install_github("UCL/mimix")
