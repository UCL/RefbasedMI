# when reading in Stata sigmas
S11 <-SigmaRefer[[1]][c_mata_nonmiss,c_mata_nonmiss]
S12 <-matrix(SigmaRefer[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss))
S22 <-SigmaRefer[[1]][c_mata_miss,c_mata_miss]
Sigma<- SigmaRefer
}
############# individual analysis #########################
}
#else if(!is.null(methodindiv[1]))
else if (flag_indiv==1) {
# call function for  indiv
indparamlist  <- ifmethodindiv(methodindiv,mg,m,M,paramBiglist,i,treatvar,c_mata_nonmiss,c_mata_miss,mata_miss,mata_nonmiss)
mata_means<- indparamlist[[1]]
Sigma <- indparamlist[[2]]
}
# loop still open for row(mg)
###################### MNAR IMPUTATION ################
# need insert routine when ALL missing values
# else
###################### MNAR IMPUTATION ################
#make sure these are single row vectors! as mistake in LMCF but have to be duplicate rows so add ,s
#and move after dup fun
S11 <-Sigma[[1]][c_mata_nonmiss,c_mata_nonmiss]
S12 <-matrix(Sigma[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss))
S22 <-Sigma[[1]][c_mata_miss,c_mata_miss]
# need to repictae mata_means to same numbe rrows as data pattern group
# causing problems replace with simpler
mata_means<-mata_means[rep(seq_len(nrow(mata_means)),each=mg$X1[i]),]
#perhaps put zeros in ? to make sure same length??
if (!is.null(nrow(mata_means)) )  {
m1 <- mata_means[,c_mata_nonmiss]
m2 <- mata_means[,c_mata_miss]
} else {
m1 <- mata_means[c_mata_nonmiss]
m2 <- mata_means[c_mata_miss]
}
#then mata_obs is the sequential selection of rows according to the mimix_group variable X1 values
#need a counter to accumulate j  - easiest way is to ceate a cumulstive col in mimix_group
j <- mg[i,"X1"]
#for debug
#print(paste0(" count in patt = ", j))
k <- mg[i,"X1cum"]
startrow <-(k-j+1)
stoprow  <-(k)
#raw1 <- mata_obs[, c_mata_nonmiss]
# preraw <- mata_Obs[c(startrow:stoprow),2:ncol(mata_Obs)]
# drop id  cols from raw data
preraw <-(mata_Obs[c(startrow:stoprow),!(names(mata_Obs) %in% c(idvar))])
raw1 <- preraw[,c_mata_nonmiss]
##### try inserting routine for all missing values here NOt really necessary!! ### 20/1/20 #####
## when all missing data, the length of c_mata_nonmiss must exclude the no. of covariates
## temporary fix set as 1, ie no. of covars 20/01/20
# nOTE think no observed data includes no base line as well?
# all missing ? didnt think we did ths scenario, ie base depvar always complete?
if (length(c_mata_nonmiss)==0)  {
## routine copied from mimix line 1229
# change 9/5/20 becaus error list obj cannot be coerced to double
U <- chol(Sigma[[1]])
# generate inverse normal, same as used below
#for debug 20/01
#   print(paste0('mg[i,X1] =',mg[i,"X1"],' miss_count= ',miss_count))
miss_count<-sum(mata_miss)
Z <- stats::qnorm(matrix(stats::runif( mg[i,"X1"]* miss_count,0,1),mg[i,"X1"],miss_count))
# raw and m1 null fields so hut use m2
meanval = as.matrix(m2)
mata_y1 = meanval+Z%*%(U)
#set dimensions mata_new to mata_y1
#define new matrix from observed,  id column  (the last)
mata_new <- preraw
# mata_new has to be already defined
mata_new[,c_mata_miss] <- (mata_y1)
GI <- array(data=mg[i,treatvar],dim=c(mg[i,"X1"],1))
#II  no imputations
II <- array(data=m,dim=c(mg[i,"X1"],1))
# SNO just id col
SNO <- mata_Obs[c(startrow:stoprow),1]
mata_new=cbind(GI,II,mata_new,SNO)
mata_all_newlist[[m_mg_iter]]=mata_new
# 9/5/20 inser else here
} else {
#so S12 must be declare as a matrix ! as number otherwise is class number
#try transpose as was failing compatible error
#note y must have same no rows as Q
#solve Qx=y
#t_mimix =cholsolve(Q=mS11,y=(mS12))
#tryig solve instead ax=b
t_mimix=solve(S11,S12)
conds <-  S22-t(S12)%*%t_mimix
#
#meanval = as.matrix(m2) + as.matrix(raw1 - m1)%*%as.matrix(t_mimix)
# below for CR but need checks work with J2R
# need edit m2 as errormsg "data frame with 0 columns and 1 row"
# 9/3/20
#browser() the else condition not works ,m2 needs matrix
## important calculation to CHECK !!!
#depends whether meth or methodindiv used
#really this needs to be independent of which merh used
# if (meth=='J2R')
#  if  (mg[i,methodindiv[1]] == 3) {
#{  1*1 MATRIX ?
# } else if (mg[i,methodindiv[1]] == 4)   {
# m2 careful as matrix needs to be vertical , test change 17/03
# this works for accupuncture data but not asthma, because when one patient raw daa is 1 by n matrix so m2 needs to be horizontal, ie not a matrix
#19/03  11/04 works for CR but then not for J2R for 5333 patt=7 one patient
if (mg[i,"X1"] == 1) {
meanval = (m2) + as.matrix(raw1 - m1)%*%as.matrix(t_mimix)
}  else {
meanval = as.matrix(m2) + (as.matrix(raw1 - m1)%*%as.matrix(t_mimix))
}
#24/02browser()
U <- chol(conds)
# mg[i,X1] is equiv to Stata counter, miss_count is no. of missing, so
miss_count=rowSums(mata_miss)
# gen erate inverse normal
Z<-stats::qnorm(matrix(stats::runif( mg[i,"X1"]* miss_count,0,1),mg[i,"X1"],miss_count))
# check same input parameters for inverse norm gen as in stata
#for debug 20/01
#  print(paste0('mg[i,X1] =',mg[i,"X1"],' miss_count= ',miss_count))
#mata_y1 = meanval+Z%*%t(U)  14/01/20 try without transpose because Stata Cholesky lower tri, R upper (or vice versa)
mata_y1 = meanval+Z%*%(U)
#define new matrix from observed,  id column  (the last)
mata_new <- preraw
# assigning the columns where the missing values
# was nct (as in stata) = no ntimes + ncovar
# so if no missing then just copy full values into mata_new columns
#if(length(c_mata_miss)==0 ) { mata_new[,c(1:length(tst2))] <- mata_Obs[,c(2:length(tst2))]
if(length(c_mata_miss)==0 ) { mata_new[,c(1:length(tst2))] <- preraw[,c(1:length(tst2))]
}else
{
mata_new[,c_mata_miss] <- mata_y1
}
# if(length(c_mata_miss)!=0 )
#save U,Z for imp(m) and patt(i)
# this worked for Z
#assuming this  from Stata if "`interim'"==""{
# SNO just id col
SNO <- mata_Obs[c(startrow:stoprow),1]
#SNO <- mata_ObsX[,ncol(mata_Obs)]
# GI treatment grp column 1 (here),II imputation number col, mata_new matrix then SNO is id col.
GI <- array(data=mg[i,1],dim=c(mg[i,"X1"],1))
#II  no imputations
II <- array(data=m,dim=c(mg[i,"X1"],1))
#doesnt need SNO, as id already in
#mata_new<-cbind(GI,II,mata_new,SNO)
#this works but bette to pre initialise data structure outsidr loop
mata_new<-cbind(GI,II,mata_new,SNO)
#assume delta to be used if specified in input argument
if (length(delta != 0) ) {
#browser()
mata_new <-  AddDelta(tst2,  ncovar_i,mata_new,delta)
}
mata_all_newlist[[m_mg_iter]]=mata_new
#mata_all_new<-rbind(mata_all_new,mata_new)
#mata_all_new<- na.omit(mata_all_new)
#stata equilv \ is row bind NOt cbind!!?
#9/5/20 end else c_mata_nonmiss ==0 here
}
} # ( m in  1:M) so insert delta module just before this
} #for row[mg]
} #for M StOP HERE!!
# 23/03 addon to save as implist
#  browser()
#  dimlist <- (nrow(mg[[1]])*M)
# extract from nested list
# combine into data set containing M imputed datasets
#  mata_all_newData1x <- do.call(rbind,mata_all_newlist[[1]])
# then sort (by imputation and patient id) into M data sets and split into M lists
#  impdatasets <- mata_all_newData1x[order(mata_all_newData1x$II,mata_all_newData1x$SNO),]
#  impdatasets2 <- mata_all_newlist[order(mata_all_newlist$II,mata_all_newlist$SNO),]
impdataset<-getimpdatasets(list(mata_all_newlist,mg,M,meth))
#return(list(mata_all_newlist,mg,M,meth))
return(impdataset)
} # for mimix test
#' @title getimpdatasets
#' @description to obtain the M imputed data set from the output list into one dataset
#' @details This combines the imputations found from the M pattern groups
#' @param varlist  list of data containing imputed values from the M pattern groups
#' @return impdataset
getimpdatasets <- function(varlist){
#9/5/20
#browser()
# to obtain M imputed data sets
# dimension of data set, nrows in pattern times no imputations,
# note sub data sets wi have different cols if completely missing so
mata_all_newlist<-  varlist[1]
mg<-(varlist[2])
M<- unlist(varlist[3])
meth<- unlist(varlist[4])
#dimlist <- (nrow(mg[[1]])*M)
# extract from nested list
# combine into data set containing M imputed datasets
mata_all_newData1x <- do.call(rbind,mata_all_newlist[[1]])
# then sort (by imputation and patient id) into M data sets and split into M lists
impdatasets <- mata_all_newData1x[order(mata_all_newData1x$II,mata_all_newData1x$SNO),]
#############################################
# now recreate orig data set by selecting 1st imputed data set and setting NAs using .miss dummies
imp1st<-impdatasets[impdatasets$II=="1",]
col_miss<-(imp1st[,grepl(".miss",colnames(imp1st))])
# get header of missing
hd_miss <- colnames(imp1st[,grepl(".miss",colnames(imp1st))])
# strp .miss to gt orig vars names
hd_new <- gsub(pattern=".miss",replacement = "", hd_miss)
# converting the 1's in .miss columns to NAs then
# replace dummy 0,1 by 0,na
imp1st_NA <- apply(col_miss, MARGIN =2, function(x) ifelse(x==1,NA,x) )
#assign  0 imputation number to unimputed dataset
imp1st$II <-0
# overwrite .miss cols with 0,NA  instead of 0,1
imp1st[,hd_new]<-(imp1st[,hd_new] +imp1st_NA)
# now combine recreated original with impute data
impdatasetsmiss<-rbind(imp1st,impdatasets)
# no reason to keep the dummies
# and they cause a warning on setting  as.mids() function
impdatasets <- impdatasetsmiss[,-grep(".miss",colnames(impdatasetsmiss))]
#impdatasets <- as.mids(tmpdatasets, .id="SNO",.imp="II")
return(impdatasets)
}
#' mimix: A package for Reference-based imputation for longitudinal clinical trials with protocol deviation
#'
#' similar to the Stata mimix function
#'
#'  The mimix package contains the functions preprodata and preproIndivdata to
#'  process long longitudinal data into wide data format
#'
#'  Also the function Addelta to add delta adjustment to the imputed estimates
#' @docType package
#' @name mimix
NULL
# so no almost reday for mice!
#fit<-with(data= as.mids(impanticausalun, .id="SNO",.imp="II"), expr = lm(HAMD17.TOTAL.7~TREATMENT.NAME+basval+POOLED.INVESTIGATOR+PATIENT.SEX))
#summary(pool(fit))
devtools::document()
mimix::mimix()
?mimix::mimix
package?mimix()
package?mimix
package?mimix::acupuncture
package?mimix
mimix
?mimix
package?mimix
devtools::document()
######################################### asthma data-set testing J2R method #############################################
# testing all options, m=5 imputations , method = J2R, referEnce treatment gp =1,seed = 101,  Delta specified
impdatasetJ2R<-mimix("asthma",c("base"),"fev","treat","id","time",5,1,"J2R",101,"jeffreys",1000,NULL,NULL,c(0.5,0.5,1,1 ),NULL )
############################################# Test Causal method, when Kd = 0 same as J2R, Kd=1 same as CIR
impantiCausal_2NoDelta <- mimix("antidepressant",c("basval","PATIENT.SEX"),"HAMD17.TOTAL","TREATMENT.NAME","PATIENT.NUMBER","VISIT.NUMBER",5,1,"Causal",101,c("jeffreys"),1000,NULL,NULL,,2)
#recode treatment variable to numeric
#antidepressant$TREATMENT.NAME<-ifelse(antidepressant$TREATMENT.NAME=="PLACEBO",1,ifelse(antidepressant$TREATMENT.NAME=="DRUG",2,99))
#recode covarates to numeric
antidepressant$PATIENT.SEX <- as.numeric(antidepressant$PATIENT.SEX)
############################################# Test Causal method, when Kd = 0 same as J2R, Kd=1 same as CIR
impantiCausal_2NoDelta <- mimix("antidepressant",c("basval","PATIENT.SEX"),"HAMD17.TOTAL","TREATMENT.NAME","PATIENT.NUMBER","VISIT.NUMBER",5,1,"Causal",101,c("jeffreys"),1000,NULL,NULL,,2)
# to install if not already installed
#if(!require(norm2)) install.packages('norm2')
#if(!require(mice)) install.packages('mice')
#for select  function
#install.packages("dplyr")
#library(dplyr)
# for pivot_wider function
#install.packages("tidyr")
#library("tidyr")
# for emNorm
#install.packages("norm2")
#library(norm2)
# for cholsolve
#install.packages("sparseinv")
#library(sparseinv)
#  for analysis (stat.desc)
#install.packages("pastecs")
#library(pastecs)
# for Amelia
#install.packages("amelia")
#library(amelia)
#' @title LMCF_loop
#' @description process LMCF method
#' @details This is based on Suzie Cro's Stata program
#' @param c_mata_miss vector of col locaton of missing values , eg 5 6
#' @param mata_Means vector of means after mcmc draws eg 17 1 16.8 15.5 14.6 13.2
#' @return mata_means
LMCF_loop <- function(c_mata_miss,mata_Means)
{
miss_count <- length(c_mata_miss)
mata_means <- mata_Means
for (b in 1:miss_count)  {
if (c_mata_miss[b] > 1) {
mata_means[c_mata_miss[b]] <- mata_means[(c_mata_miss[b]-1)]
}
}
return(mata_means)
}
#' @title CIR_loop
#' @description process CIR method
#' @details This is based on Suzie Cro's Stata program
#' @param c_mata_miss vector of col locaton of missing values , eg 5 6
#' @param mata_Means vector of means after mcmc draws eg 17 1 16.8 15.5 14.6 13.2
#' @param MeansC vector of means after mcmc draws using variance from reference group
#' @return mata_means
CIR_loop <- function(c_mata_miss,mata_Means,MeansC)
# mata_S_miss something like [2 3 4] ,so is cc
{
# browser()
miss_count <- length(c_mata_miss)
mata_means <- as.data.frame(mata_Means)
for (b in 1:miss_count)  {
# if 1st col missing then no value before so need to check for that
# note mimix counter just no rows in each patt
# so main looping is over missin fields, ie miss_count
# if 1st col must be ref
if (c_mata_miss[b] ==1) {
#print will cause objectto return
#print(paste0(miss_count))
#for each patt_count (from mimix_group)
#test purposes
#count<-2
# MeansC is list so use [[1]]
mata_means[b] <- MeansC[[1]][b]
} else  {
#filling in column at a time
mata_means[c_mata_miss[b]] = mata_means[(c_mata_miss[b]-1)]+ MeansC[[1]][(c_mata_miss[b])]- MeansC[[1]][(c_mata_miss[b])-1]
}
}
return(mata_means)
}
#' @title Causal_loop
#' @description process Causal method
#' @details This is based on "White,Royes,Best" paper
#' @param c_mata_miss vector of col locaton of missing values , eg 5 6
#' @param mata_Means vector of means after mcmc draws eg 17 1 16.8 15.5 14.6 13.2
#' @param MeansC vector of means after mcmc draws using variance from reference group
#' @param  Kd parameter that makes it between J2R and CIR, value 1 equiv to CIR
#' @return mata_means
Causal_loop<- function(c_mata_miss,mata_Means,MeansC,Kd)
{
# browser()
miss_count <- length(c_mata_miss)
mata_means <- as.data.frame(mata_Means)
for (b in 1:miss_count)  {
# if 1st col missing then no value before so need to check for that
# note mimix counter just no rows in each patt
# so main looping is over missin fields, ie miss_count
# if 1st col must be refn
if (c_mata_miss[b] ==1) {
#print will cause objectto return
#print(paste0(miss_count))
#for each patt_count (from mimix_group)
#test purposes
#count<-2
# MeansC is list so use [[1]]
mata_means[b] <- MeansC[[1]][b]
} else  {
#filling in column at a time
# mata_means[c_mata_miss[b]] = mata_means[(c_mata_miss[b]-1)]+ Kd*( MeansC[[1]][(c_mata_miss[b])]- MeansC[[1]][(c_mata_miss[b])-1])
# assuming  mata_means[t]- MeansC[[1]][t] is depature from overall mean , ie MyCov in sas macro
# find time of discontinuation (ignoring interim cases?)
# establish time of last visit ( asunming no interims for now!)
# eg c_mata_miss = (2,3,4) shows missing cols
#lastvisit is time t in Ian's paper
lastvisit <-min(c_mata_miss)-1
# departure from overall mean at time t (lastvist) , active mean - ref mean at last visit
ActRef_diff <-mata_means[lastvisit]-MeansC[[1]][lastvisit]
# 1/5/20 need to compere v CIR , J2R and doesnt use terms in  formula 7
mata_means[c_mata_miss[b]] <- MeansC[[1]][c_mata_miss[b]]+  ( Kd*ActRef_diff )
#mata_means[c_mata_miss[b]] <-   *(mata_means[(c_mata_miss[b]-1)]- MeansC[[1]][(c_mata_miss[b])-1]) + (mata_means[(c_mata_miss[b])]-MeansC[[1]][(c_mata_miss[b])])
}
}
return(mata_means)
}
#' @title regressimp
#' @description run regression on M imputed data set, combining as Rubin's rules
#' @details This is approach followed from  norm2 user manual
#' @export regressimp
#' @param dataf data-frame
#' @param regmodel regression model specfication
#' @return estimates of regression coefficients
#' @example
#' \dontrun{
#' regressimp(impdataset,"fev.12~treat+base")
#' }
regressimp <- function(dataf,regmodel)  {
# to get the list
implist1x <- split(dataf,dataf[,"II"])
# so has M elements in list
# can obtain a list of coefficients and their se's from a regression
# declare list for estimates
est.list <- as.list(NULL)
# declare lists for se's
std.err.list <- as.list( NULL )
M<- utils::tail(dataf[,"II"],1)
for( m in 1:M ){
#mod<-lm(fev12~as.factor(treat)+base,data=kmlist1x[[m]] )
#mod<-lm(head12~head_base+sex,data=implist1x[[m]] )
#mod<-lm(HAMD17.TOTAL7~basval+HAMD17.TOTAL6,data=implist1x[[m]] )
mod<-stats::lm(regmodel,data=implist1x[[m]] )
est.list[[m]] <- stats::coef(summary(mod))[,1]
std.err.list[[m]] <- stats::coef(summary(mod))[,2]
}
## combine the results by rules of Barnard and Rubin (1999)
## with df.complete = 27, because a paired t-test in a dataset with
## N=28 cases has 27 degrees of freedom
miResult <- norm2::miInference(est.list, std.err.list, df.complete=801)
print(miResult)
# trying mcerror
#return(list(est.list,std.err.list))
}
#' @title analyselist
#' @description find descriptive stats on the  M imputed data set
#' @details select on patient id and find their means etc
#' @export analyselist
#' @param id patient identifier
#' @param datlist imputed dataset of M imputations
#' @param varlist list of derived variables ,varlist <- c("fev.2","fev.4","fev.8","fev.12","base")
#' @return printout of descriptve stats
#' @example
#' \dontrun{
#' varlist <- c("fev.2","fev.4","fev.8","fev.12","base")
#' analyselist(5099,impdataset,varlist)
#' }
analyselist <-function(id,datlist,varlist) {
datano <- subset(datlist,id==datlist$SNO)
# numbers denote the descriptive stats to display
t(round(pastecs::stat.desc(datano)[,varlist],3)[c(1,9,13,4,8,5),])
}
#' @title AddDelta
#' @description add delta's to imputed values
#' @details adding delta values after wthdrawal
#' @param vec_tst  vector of visit names
#' @param ncovar number covariates
#' @param mata_imp the imputed values (as well as the complete)
#' @param delta vector of delta values for each vist time
#' @return mata_imp the adjusted imputed vaues (and unadjusted non-missing)
#define function 19/04 to add delta's to imputed values
AddDelta<-function(vec_tst,ncovar,mata_imp,delta)  {
#browser()
# create vector of 1 and 0s
#browser()  no space before .miss 12/5/20, stat at 3rd col skipping GI II
#onezero<-sapply(vec_tst[3:(2+length(vec_tst)-ncovar)], function(x) return(mata_imp[1,paste0(x,".miss")]))
onezero<- sapply(vec_tst, function(x) return(mata_imp[1,paste0(x,".miss")]))
#drop covariates (which should be complete anyway)
dropcovar <- ncovar+1
onezero<-onezero[c(dropcovar:length(onezero))]
# then 1st and last  ,set last0 as last of complete  before the missing values start
# but as to go in if because min(0,0,..) cause warnings
#lastVisit <- min(which(unlist(onezero)==1))
# check not interim , ie no gaps in onezero seq
# in which case just leave wout delta adjustment but print warnnig msg
# if length = max then no gaps
# if all 0's the no missing so no adjustment required
#if (sum(which(unlist(onezero)!=0) ) ) {
# check no gaps, ie interims, not quite right!
#if ( length(which(unlist(onezero)==1)) == max(which(unlist(onezero)==1)) ){
#  lastVisit <- min(which(unlist(onezero)==1)) }
lastvisit <- min(which(unlist(onezero)==1))-1
# so add appropriate delta to imputed values after last visit
super_delta<-0
v<-0
# for (v in lastVisit:length(onezero)) {
# when dlag used super_delta<- super_delta + delta[v]* dlag[v-1]
# we only increment delta when missing, so skip if non imssing
# 1st row should be same value for all rows in the same pattern group, gives warning othewise
# range of values to be changed in mata_imp given by the cols start:end
start<- 2+ncovar+1
end <- 2+length(vec_tst)
#mata_imp[,start:end]
#loop ove selected range in mata_imp
for (j in (start+lastvisit):end) {
#4:8
#if (mata_imp[1,start+v]==1) {
# adjust from last visit (ignore interims for now)
#for (v in lastVisit:length(onezero)) {
# count from start to end
v<- v+1
super_delta <- super_delta + delta[v]
mata_imp[j] <- mata_imp[j] + super_delta
}
#browser()
# mata_new values start in col 3 so must add 2 to index
# needs adjusting for when interim case non missing! test dummy missing vars
# jump<-length(vec_tst)
# mata_imp[2+v]<- ifelse(mata_imp[2+v+1+jump]==1,mata_imp[2+v] + super_delta,mata_imp[2+v])
#{
#print(paste0("interim missing, check delta adjustment ",onezero))
# mata_imp[2+v] <- mata_imp[2+v] + super_delta
return(mata_imp)
}
devtools::document()
getwd()
############################################# Test Causal method, when Kd = 0 same as J2R, Kd=1 same as CIR
impantiCausal_2NoDelta <- mimix("antidepressant",c("basval","PATIENT.SEX"),"HAMD17.TOTAL","TREATMENT.NAME","PATIENT.NUMBER","VISIT.NUMBER",5,1,"Causal",101,c("jeffreys"),1000,NULL,NULL,,2)
library(mimix)
############################################# Test Causal method, when Kd = 0 same as J2R, Kd=1 same as CIR
impantiCausal_2NoDelta <- mimix("antidepressant",c("basval","PATIENT.SEX"),"HAMD17.TOTAL","TREATMENT.NAME","PATIENT.NUMBER","VISIT.NUMBER",5,1,"Causal",101,c("jeffreys"),1000,NULL,NULL,,2)
############################################# Test Causal method, when Kd = 0 same as J2R, Kd=1 same as CIR
impantiCausal_2NoDelta <- mimix("tidepressant",c("basval","PATIENT.SEX"),"HAMD17.TOTAL","TREATMENT.NAME","PATIENT.NUMBER","VISIT.NUMBER",5,1,"Causal",101,c("jeffreys"),1000,NULL,NULL,,2)
############################################# Test Causal method, when Kd = 0 same as J2R, Kd=1 same as CIR
impantiCausal_2NoDelta <- mimix("antidepressant",c("basval","PATIENT.SEX"),"HAMD17.TOTAL","TREATMENT.NAME","PATIENT.NUMBER","VISIT.NUMBER",5,1,"Causal",101,c("jeffreys"),1000,NULL,NULL,,2)
impantiJ2R <- mimix("antidepressant",c("basval","PATIENT.SEX"),"HAMD17.TOTAL","TREATMENT.NAME","PATIENT.NUMBER","VISIT.NUMBER",100,1,"J2R",101,c("jeffreys"),1000,NULL,NULL,,1)
detach("package:mimix", unload = TRUE)
############################################# Test Causal method, when Kd = 0 same as J2R, Kd=1 same as CIR
impantiCausal_2NoDelta <- mimix("antidepressant",c("basval","PATIENT.SEX"),"HAMD17.TOTAL","TREATMENT.NAME","PATIENT.NUMBER","VISIT.NUMBER",5,1,"Causal",101,c("jeffreys"),1000,NULL,NULL,,2)
getwd()
library(mimix)
############################################# Test Causal method, when Kd = 0 same as J2R, Kd=1 same as CIR
impantiCausal_2NoDelta <- mimix("antidepressant",c("basval","PATIENT.SEX"),"HAMD17.TOTAL","TREATMENT.NAME","PATIENT.NUMBER","VISIT.NUMBER",5,1,"Causal",101,c("jeffreys"),1000,NULL,NULL,,2)
###################################### J2R no covars
impacupJ2R_nocovars <- mimix(NULL,"head","treat","id","time",5,1,data="acupuncture","J2R",201,c("jeffreys"),1000,NULL,NULL)
###################################### LMCF
impacupLMCF_2covar <- mimix(c("head_base","sex"),"head","treat","id","time",5,1,data="acupuncture","LMCF",201,,1000,NULL,NULL)
detach("package:mimix", unload = TRUE)
devtools::document()
############################################# Test Causal method, when Kd = 0 same as J2R, Kd=1 same as CIR
impantiCausal_2NoDelta <- mimix("antidepressant",c("basval","PATIENT.SEX"),"HAMD17.TOTAL","TREATMENT.NAME","PATIENT.NUMBER","VISIT.NUMBER",5,1,"Causal",101,c("jeffreys"),1000,NULL,NULL,,2)
