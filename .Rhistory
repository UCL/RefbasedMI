#  the row  orders are ok but the col order may be wrong ,have to check!
# construct structure to savde interim ids but this get reinitialised to many times!
#11/11 interim_id<- mata_Obs[c(mg[i,1]),"id"]
#browser(text="no missing values")
# if no missing values
if(length(c_mata_miss)==0 ) {
# start and end row positions
st<-mg[i,"cumcases"]-mg[i,"cases"]+1
en <-mg[i,"cumcases"]
# id (SNO) is 1st col
# either reorganise mata_Obs so id is 1st col  or use id as col name 0812
#SNO<-mata_Obs[c(st:en),1]
SNO<-mata_Obs[c(st:en),".id"]
#21/07/20
#browser()
# this doesnt delete treat
#mata_new <- mata_Obs[c(st:en),2:ncol(mata_Obs)]
mata_new<-mata_Obs[c(st:en),!(names(mata_Obs) %in% c(idvar))]
#browser() # treat defined within fun
GI <- array(data=mg[i,treatvar],dim=c(mg[i,"cases"],1))
#II  no imputations
II <- array(data=m,dim=c(mg[i,"cases"],1))
mata_new=cbind(GI,II,mata_new,SNO)
#names(mata_all_new)<-names(mata_new)
mata_all_newlist[[m_mg_iter]]=mata_new
# mata_all_new=rbind(mata_all_new,mata_new)
# else if there are missing values
} else {
# need to distinguish between meth and methodindiv
if (flag_indiv==0 ) {
referindex<- reference
#FOR INDIVIDUALS WITH  MISSING DATA  `m' TIMES
# dependent on method chosen
# 'MAR'
#browser(text="2611")
if (method== 1)  {
# 11/11 checking methd used for interims in J2R works as MAR
#mata_means <- get(paste0("param",trtgp,m))[1]
mata_means <- paramBiglist[[M*(trtgpindex-1)+m]][1]
# mata_means<-mata_means[rep(seq(nrow(mata_means)),each=mg$X1[i]),]
# convert from list element to matrix
mata_means <- mata_means[[1]]
#Sigmatrt <- get(paste0("param",trtgp,m))[2]
Sigmatrt <- paramBiglist[[M*(trtgpindex-1)+m]][2]
S11 <-Sigmatrt[[1]][c_mata_nonmiss,c_mata_nonmiss]
#S12 <-Sigmatrt[[1]][c_mata_nonmiss,c_mata_miss]
# to ensure col pos same as stata
S12 <-matrix(Sigmatrt[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss))
S22 <-Sigmatrt[[1]][c_mata_miss,c_mata_miss]
#11/11 flag interims put in as option in command
# testinterim<-1
#initialise interim
# interim<-0
if (testinterim==1) {
# need to find the interim cols so as to set values as MAR
miss_count <- length(c_mata_miss)
# cndition if miss_count =1 then only 1 missing  and if Not at end eg c_mata_miss = 5 then by defn is an interim!
#browser()
#tryng to put sigma from MAR in ,works for 533 but not 5051 but once did before putting in j2r sigma at bottom,
# MAR sigma gives correc tinterim but incorrect subsequents
# 1st phase to find interims and apply MAR sigmas
if ((miss_count == 1) & (c_mata_miss[1] < length(mata_means)) ) # 1 missing and not at end point 5115
{
interim<-1
#     cat(paste0("miss+_count=1 paramBiglist= ?"))
} else if (miss_count >1)  # if more than 1 missing
{
#assuming 1st col non-missing so start at  5333 is failing xxx0 234  being treated as a J2R!
for (b in 2:(miss_count)) {    # last miss_count end pt check separately below
#              # c_mata_miss vector of missing locations so if next col not missing then will be gap in sequence
# c_mata_miss[b] is interim so overwrite with MAR value
# adjust when only last col missing (patt=8) ie c_mata_miss = 5
#  245 => b = 1,2,3
if ((c_mata_miss[b-1]+1) != c_mata_miss[b])  # so next entry after c_mata_miss[b] is non-missing
# so interim found but what if next one missing, need to check
{
#browser() MAR sigma
interim<-1
#browser()
#cat(paste0("interim at ",m_mg_iter ,"SNO=",SNO, "b=",b  ))
if (m==1) {
cat(paste0("\ninterim at ",m_mg_iter , "b=",b , "id= ", mata_Obs[c(mg[i,"cumcases"]),"id"] ))
}
# construct vector to save interims ids
#11/11   interim_id <- rbind(interim_id, mata_Obs[c(mg[i,"cumcases"]),"id"] )
} else if  ( (c_mata_miss[b-1]+1 == c_mata_miss[b]) & ( c_mata_miss[b-1] < max(c_mata_nonmiss)) )   # need to check there is a non-missing to the right, eg 23 5 , 234 all interims!
#  cat(paste0("check nonmissing to right")) trying to catch 5333 7/ this s not going to affect when b=miss_count so need add for this condition
{ interim<-1
} #need to include outside the for loop  when condition b=miss_count
} #if
} #for
#  else if doesnt work need to process the miss_count element because not processed in for loop
#else if ( (b==miss_count) & ( c_mata_miss[b] < length(mata_means)) )
if  ((c_mata_miss[miss_count]) < length(mata_means) )
{
interim<-1
if (m==1) {
cat(paste0("\ninterim at ",m_mg_iter , "b=",b , "id= ", mata_Obs[c(mg[i,"cumcases"]),"id"] ))
}
#11/11   interim_id<-  rbind(interim_id, mata_Obs[c(mg[i,"cumcases"]),"id"])
# end sigma test successful
} #if
# browser()
} #testinterim  processed save  interim_ids
# Sigma<-Sigmatrt
}
# 'J2R'
else if (method == 3 ) {
# changed saving the result into  just the param file, list of 2 so can use list index here
#treatmnets are 1.. M then M+1 ..2M .. etc
mata_means_trt <- paramBiglist[[M*(trtgpindex-1)+m]][1]
mata_means_ref <- paramBiglist[[M*(referindex-1)+m]][1]
#browser(text="pass2method")
# below causes error after using >1 covars and mata_nonmiss has covar.1, not proper covar names
# try not unisting because error only fr J2r merod when on patien in patt
#
# 2/11
# browser()
mata_means_t <-lapply(mata_means_trt,FUN = function(x) x*mata_nonmiss)
#mata_means_t <- unlist(mata_means_trt)*mata_nonmiss
# print(paste0("mata_means_trt, mata_nonmiss= ",mata_means_trt,mata_miss))
mata_means_r <-lapply(mata_means_ref,FUN = function(x) x*mata_miss)
#mata_means_r <- unlist(mata_means_ref)*mata_miss
# so when all missing  1,1,1, ... then all contributing comes from reference means
mata_means <- unlist(mata_means_r)+unlist(mata_means_t)
#try this 11/04
mata_means<-(as.matrix(t(mata_means)))
# and preserve names
# 11/04 colnames(mata_means) <-  colnames(mata_means_t[[1]])
#replicate to number of rows defined by X1
#mata_means<-mata_means[rep(seq(nrow(mata_means)),each=mg$X1[i]),]
############# SIGMA is from paramsigma  the reference group ################
# do we ever  use SigmaTrt !!?? in j2r?
# answer is ??, need to use SigmaTrt for the predeviation observations, ie up to where they go missing
# only after they go missing (trailing missing) need to use the SigmaRef
#9/3/20
SigmaRefer <- paramBiglist[[M*(referindex-1)+m]][2]
#SigmaRefer <- paramBiglist[[M*(referindex-1)+m]][2]
#SigmaRefer <- get(paste0("paramBiglist",refer,m))[2]
Sigmatrt <- paramBiglist[[M*(trtgpindex-1)+m]][2]
# note use of [[1]] as is matrix rathe than list,
S11 <-SigmaRefer[[1]][c_mata_nonmiss,c_mata_nonmiss]
# causes non-def error in conds
#to ensure rows and cols as should reflect their stucture use matrix
S12 <-matrix(SigmaRefer[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss))
S22 <-SigmaRefer[[1]][c_mata_miss,c_mata_miss]
################test here just to see if get same tment effect inserting J2Rsigma##########
#9/3/20 7/11/20
##### yes this has the effect of obtaining same treastment effect as J2R , ie 0.1166 so hopefully run this after running MAr
#      SigmaRefer <- paramBiglist[[M*(referindex-1)+m]][2]
#      #SigmaRefer <- paramBiglist[[M*(referindex-1)+m]][2]
#SigmaRefer <- get(paste0("paramBiglist",refer,m))[2]
#        Sigmatrt <- paramBiglist[[M*(trtgpindex-1)+m]][2]
# note use of [[1]] as is matrix rathe than list,
#        S11 <-SigmaRefer[[1]][c_mata_nonmiss,c_mata_nonmiss]
# causes non-def error in conds
#to ensure rows and cols as should reflect their stucture use matrix
#        S12 <-matrix(SigmaRefer[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss))
#        S22 <-SigmaRefer[[1]][c_mata_miss,c_mata_miss]
#################### delete above !!! afte test ######################################
#10/11
#    browser()
} #method
# 'CR'
else if (method==2) {
# no need to use Sigmatrt here
mata_means <- paramBiglist[[M*(referindex-1)+m]][1]
#mata_means <- get(paste0("param",refer,m))[1]
# convert from list to matrix
mata_means <- mata_means[[1]]
SigmaRefer <- paramBiglist[[M*(referindex-1)+m]][2]
S11 <-SigmaRefer[[1]][c_mata_nonmiss,c_mata_nonmiss]
S12 <-matrix(SigmaRefer[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss) )
S22 <-SigmaRefer[[1]][c_mata_miss,c_mata_miss]
#Sigma<-SigmaRefer
}
# 'CIR'
else if (method==4)
{
# need to use Sigmatrt as in j2r
# pre-deviating use mean of trt gp up to last obs time bfore deviating, post-deviating use mean from ref grp
# put equiv to mimix
#mata_Means <- get(paste0("param",trtgp,m))[1]
mata_Means <- paramBiglist[[M*(trtgpindex-1)+m]][1]
# convert from list to matrix
mata_Means <- mata_Means[[1]]
#mata_Means <-  get(paste0("parambeta",trtgp,m))
#MeansC <-  get(paste0("param",refer,m))[1]
MeansC <-  paramBiglist[[M*(referindex-1)+m]][1]
#might be better to copy mimix algol
mata_means<-CIR_loop(c_mata_miss,mata_Means,MeansC)
#returns mata_means as single row
# then duplicate over patt rows
#replicate to number of rows defined by X1
# mata_means<-mata_means[rep(seq(nrow(mata_means)),each=mg$X1[i]),]
#SigmaRefer <- get(paste0("paramsigma",refer,m))
#SigmaRefer <- get(paste0("param",refer,m))[2]
SigmaRefer <- paramBiglist[[M*(referindex-1)+m]][2]
# when reading in Stata sigmas
S11 <-SigmaRefer[[1]][c_mata_nonmiss,c_mata_nonmiss]
S12 <-matrix(SigmaRefer[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss))
S22 <-SigmaRefer[[1]][c_mata_miss,c_mata_miss]
# Sigma<- SigmaRefer
}
# 'LMCF'
else if (method==5) {
#mata_Means <-  get(paste0("param",trtgp,m))[1]
mata_Means <- paramBiglist[[M*(trtgpindex-1)+m]][1]
# convert from list to matrix
mata_Means <- mata_Means[[1]]
# no ref MeansC <- mata_means_ref
mata_means<-LMCF_loop(c_mata_miss,mata_Means)
#mata_means<-mata_means[rep(seq(nrow(mata_means)),each=mg$X1[i]),]
#Sigmatrt <- get(paste0("param",trtgp,m))[2]
Sigmatrt <- paramBiglist[[M*(trtgpindex-1)+m]][2]
# when reading in Stata sigmas
S11 <-Sigmatrt[[1]][c_mata_nonmiss,c_mata_nonmiss]
S12 <-matrix(Sigmatrt[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss))
S22 <-Sigmatrt[[1]][c_mata_miss,c_mata_miss]
#   Sigma<- Sigmatrt
}  #if meth=5
# causal method uses same matrices as CIR with K parameter
else if (method==66)  {
# attempt at causa model rather thsn call causal_loop
# as in J2R  16/07
#mata_means_trt <- paramBiglist[[M*(trtgpindex-1)+m]][1]
#mata_means_ref <- paramBiglist[[M*(referindex-1)+m]][1]
#mata_means_t <-lapply(mata_means_trt,FUN = function(x) x*mata_nonmiss)
#mata_means_t <- unlist(mata_means_trt)*mata_nonmiss
# print(paste0("mata_means_trt, mata_nonmiss= ",mata_means_trt,mata_miss))
#mata_means_r <-lapply(mata_means_ref,FUN = function(x) x*mata_miss)
#mata_means_r <- unlist(mata_means_ref)*mata_miss
# so when all missing  1,1,1, ... then all contributing comes from reference means
mata_means <- unlist(mata_means_r)+unlist(mata_means_t)
#try this 11/04
mata_means<-(as.matrix(t(mata_means)))
lastvisit <-min(c_mata_miss)-1
# if interim instead try something like
if (max(c_mata_miss) <length(mata_means_trt)) {
# MAR so just use the treatment arm mata_means
#   lastvisit <-max(c_mata_miss)+1, ie interims, assign to ref man or Arm mean (just defaults ?)
mata_means[c_mata_miss[b]] <- mata_means_r[c_mata_miss[b]]
}
else {
v_u=as.numeric(sub('.*\\.','',colnames(mata_means[c_mata_miss]))[b])
# test whether index lastvisit has a "*.number" format (ie whether base covariate)
#if (grep('.*\\.','',colnames(mata_means[lastvisit]))==0L  )
if (suppressWarnings(is.na(as.numeric(sub('.*\\.','',colnames(mata_means[lastvisit])))))) {
v_t<-0
}
else
{
v_t <-  as.numeric(sub('.*\\.','',colnames(mata_means[lastvisit])))
}
# could try chaging vt,vu ?
mata_means[c_mata_miss[b]] <- mata_means[c_mata_miss[b]]+K0*(K1^(v_u-v_t))*(mata_means_t[lastvisit]-mata_means_r[lastvisit])
}
# test above 16/07
#  browser()
}
else if (method==6)  {
mata_Means <- paramBiglist[[M*(trtgpindex-1)+m]][1]
# convert from list to matrix
mata_Means <- mata_Means[[1]]
#mata_Means <-  get(paste0("parambeta",trtgp,m))
#MeansC <-  get(paste0("param",refer,m))[1]
MeansC <-  paramBiglist[[M*(referindex-1)+m]][1]
#put Kd tempval
#Kd =0 eq0iv to J2R?
#Kd =1 equiv to CIR
#Kd<-0.8
#10/08/20
#browser()
mata_means<-Causal_loop(c_mata_miss,mata_Means,MeansC,K0,K1)
#  browser()
#this temporary  for test purposes until algo decided upon
SigmaRefer <- paramBiglist[[M*(referindex-1)+m]][2]
# when reading in Stata sigmas
S11 <-SigmaRefer[[1]][c_mata_nonmiss,c_mata_nonmiss]
S12 <-matrix(SigmaRefer[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss))
S22 <-SigmaRefer[[1]][c_mata_miss,c_mata_miss]
#10/08/20
#Sigma<- SigmaRefer
}
############# individual analysis #########################
}
#else if(!is.null(methodindiv[1]))
else if (flag_indiv==1) {
# call function for  indiv
indparamlist  <- ifmethodindiv(methodvar,referencevar,mg,m,M,paramBiglist,i,treatvar,c_mata_nonmiss,c_mata_miss,mata_miss,mata_nonmiss,K0,K1)
mata_means<- indparamlist[[1]]
Sigma <- indparamlist[[2]]
}
# loop still open for row(mg)
###################### MNAR IMPUTATION ################
# need insert routine when ALL missing values
# else
###################### MNAR IMPUTATION ################
#make sure these are single row vectors! as mistake in LMCF but have to be duplicate rows so add ,s
#and move after dup fun
#10/08/20 not necessary/incorrect?
#S11 <-Sigma[[1]][c_mata_nonmiss,c_mata_nonmiss]
#S12 <-matrix(Sigma[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss))
#S22 <-Sigma[[1]][c_mata_miss,c_mata_miss]
# need to repictae mata_means to same numbe rrows as data pattern group
# causing problems replace with simpler
mata_means<-mata_means[rep(seq_len(nrow(mata_means)),each=mg$cases[i]),]
#9/11
# browser()
#perhaps put zeros in ? to make sure same length??
if (!is.null(nrow(mata_means)) )  {
m1 <- mata_means[,c_mata_nonmiss]
m2 <- mata_means[,c_mata_miss]
} else {
m1 <- mata_means[c_mata_nonmiss]
m2 <- mata_means[c_mata_miss]
}
#then mata_obs is the sequential selection of rows according to the mimix_group variable X1 values
#need a counter to accumulate j  - easiest way is to ceate a cumulstive col in mimix_group
j <- mg[i,"cases"]
#for debug
#print(paste0(" count in patt = ", j))
k <- mg[i,"cumcases"]
startrow <-(k-j+1)
stoprow  <-(k)
#raw1 <- mata_obs[, c_mata_nonmiss]
# preraw <- mata_Obs[c(startrow:stoprow),2:ncol(mata_Obs)]
# drop id  cols from raw data
preraw <-(mata_Obs[c(startrow:stoprow),!(names(mata_Obs) %in% c(idvar))])
raw1 <- preraw[,c_mata_nonmiss]
##### try inserting routine for all missing values here NOt really necessary!! ### 20/1/20 #####
## when all missing data, the length of c_mata_nonmiss must exclude the no. of covariates
## temporary fix set as 1, ie no. of covars 20/01/20
# nOTE think no observed data includes no base line as well?
# all missing ? didnt think we did ths scenario, ie base depvar always complete?
if (length(c_mata_nonmiss)==0)  {
## routine copied from mimix line 1229
# change 9/5/20 becaus error list obj cannot be coerced to double
U <- chol(Sigma[[1]])
# generate inverse normal, same as used below
#for debug 20/01
#   print(paste0('mg[i,X1] =',mg[i,"X1"],' miss_count= ',miss_count))
miss_count<-sum(mata_miss)
Z <- stats::qnorm(matrix(stats::runif( mg[i,"cases"]* miss_count,0,1),mg[i,"cases"],miss_count))
# raw and m1 null fields so hut use m2
meanval = as.matrix(m2)
mata_y1 = meanval+Z%*%(U)
#set dimensions mata_new to mata_y1
#define new matrix from observed,  id column  (the last)
mata_new <- preraw
# mata_new has to be already defined
mata_new[,c_mata_miss] <- (mata_y1)
GI <- array(data=mg[i,treatvar],dim=c(mg[i,"cases"],1))
#II  no imputations
II <- array(data=m,dim=c(mg[i,"cases"],1))
# SNO just id col
# change 1012
#SNO <- mata_Obs[c(startrow:stoprow),1]
SNO <- mata_Obs[c(startrow:stoprow),".id"]
mata_new=cbind(GI,II,mata_new,SNO)
mata_all_newlist[[m_mg_iter]]=mata_new
# 9/5/20 inser else here
} else {
#so S12 must be declare as a matrix ! as number otherwise is class number
#try transpose as was failing compatible error
#note y must have same no rows as Q
#solve Qx=y
#t_mimix =cholsolve(Q=mS11,y=(mS12))
#tryig solve instead ax=b
t_mimix=solve(S11,S12)
conds <-  S22-t(S12)%*%t_mimix
#
#meanval = as.matrix(m2) + as.matrix(raw1 - m1)%*%as.matrix(t_mimix)
# below for CR but need checks work with J2R
# need edit m2 as errormsg "data frame with 0 columns and 1 row"
# 9/3/20
#browser() the else condition not works ,m2 needs matrix
## important calculation to CHECK !!!
#depends whether meth or methodindiv used
#really this needs to be independent of which merh used
# if (meth=='J2R')
#  if  (mg[i,methodindiv[1]] == 3) {
#{  1*1 MATRIX ?
# } else if (mg[i,methodindiv[1]] == 4)   {
# m2 careful as matrix needs to be vertical , test change 17/03
# this works for accupuncture data but not asthma, because when one patient raw daa is 1 by n matrix so m2 needs to be horizontal, ie not a matrix
#19/03  11/04 works for CR but then not for J2R for 5333 patt=7 one patient
if (mg[i,"cases"] == 1) {
meanval = (m2) + as.matrix(raw1 - m1)%*%as.matrix(t_mimix)
}  else {
meanval = as.matrix(m2) + (as.matrix(raw1 - m1)%*%as.matrix(t_mimix))
}
#24/02browser()
U <- chol(conds)
# mg[i,cases] is equiv to Stata counter, miss_count is no. of missing, so
miss_count=rowSums(mata_miss)
# gen erate inverse normal
Z<-stats::qnorm(matrix(stats::runif( mg[i,"cases"]* miss_count,0,1),mg[i,"cases"],miss_count))
# check same input parameters for inverse norm gen as in stata
#for debug 20/01
#  print(paste0('mg[i,X1] =',mg[i,"X1"],' miss_count= ',miss_count))
#mata_y1 = meanval+Z%*%t(U)  14/01/20 try without transpose because Stata Cholesky lower tri, R upper (or vice versa)
mata_y1 = meanval+Z%*%(U)
#define new matrix from observed,  id column  (the last)
mata_new <- preraw
# assigning the columns where the missing values
# was nct (as in stata) = no ntimes + ncovar
# so if no missing then just copy full values into mata_new columns
#if(length(c_mata_miss)==0 ) { mata_new[,c(1:length(tst2))] <- mata_Obs[,c(2:length(tst2))]
if(length(c_mata_miss)==0 ) { mata_new[,c(1:length(tst2))] <- preraw[,c(1:length(tst2))]
}else
{
mata_new[,c_mata_miss] <- mata_y1
}
# if(length(c_mata_miss)!=0 )
#save U,Z for imp(m) and patt(i)
# this worked for Z
#assuming this  from Stata if "`interim'"==""{
# SNO just id col
# chg 1012SNO <- mata_Obs[c(startrow:stoprow),1]
SNO <- mata_Obs[c(startrow:stoprow),".id"]
#SNO <- mata_ObsX[,ncol(mata_Obs)]
# GI treatment grp column 1 (here),II imputation number col, mata_new matrix then SNO is id col.
GI <- array(data=mg[i,1],dim=c(mg[i,"cases"],1))
#II  no imputations
II <- array(data=m,dim=c(mg[i,"cases"],1))
#doesnt need SNO, as id already in
#mata_new<-cbind(GI,II,mata_new,SNO)
#this works but bette to pre initialise data structure outsidr loop
mata_new<-cbind(GI,II,mata_new,SNO)
#assume delta to be used if specified in input argument
if (length(delta != 0) ) {
# browser()
mata_new <-  AddDelta(tst2,  ncovar_i,mata_new,delta,dlag)
}
mata_all_newlist[[m_mg_iter]]=mata_new
#mata_all_new<-rbind(mata_all_new,mata_new)
#mata_all_new<- na.omit(mata_all_new)
#stata equilv \ is row bind NOt cbind!!?
#9/5/20 end else c_mata_nonmiss ==0 here
}
} # ( m in  1:M) so insert delta module just before this
} #for row[mg]
# check for interim 11/11
# browser()
} #for M StOP HERE!!
# browser(text="passtoloop")
browser(text="1012")
impdataset<-getimpdatasets(list(mata_all_newlist,mg,M,method))
# but need to adjust orig data set to set interims back to missing
# get .imp=0 's
assign(paste0("Imp_Interims_",0),subset(as.matrix(Imp_Interims[Imp_Interims$.imp==0,])))
# find depvar vars  cols
ImpInters <-    get(paste0("Imp_Interims_",0))
# note keep .imp so can use as match with impdaset and also presreve same col pos
test_Imp <- subset(ImpInters,select=-c(patt,treat))
#df1<-as.data.frame(mata_Obs)
test_Imp<-as.data.frame(test_Imp)
depcolsf<- grep(paste0(depvar),names(impdataset))
# assume thes coorespnd with interim lookup ! prob ned a check here!!
for ( pos in 1:length(depcolsf)) {
#if (impdataset$.imp==0 )
#impdataset[,depcolsf[pos]][match(test_Imp$.id,impdataset$.id)]<-test_Imp[,depcolsf[pos]]
impdataset[,depcolsf[pos]][match(paste(test_Imp$.id,test_Imp$.imp),paste(impdataset$.id,impdataset$.imp))]<-test_Imp[,depcolsf[pos]]
}
return(impdataset)
}
impdatasetMARnoDnoBase<-mimix("asthma",c("base"),"fev","treat","id","time",M=3,2,"J2R",54321,"jeffreys",1000,NULL,NULL,NULL,NULL,NULL,testinterim=1 )
head(impdatasetMARnoDnoBase)
edit(impdatasetMARnoDnoBase)
impdatasetMARnoDnoBase<-mimix("asthma",c("base"),"fev","treat","id","time",M=3,2,"J2R",54321,"jeffreys",1000,NULL,NULL,NULL,NULL,NULL,testinterim=1 )
test_Imp
edit(impdatasetMARnoDnoBase)
impdatasetMARnoDnoBase<-mimix("asthma",c("base"),"fev","treat","id","time",M=1000,2,"J2R",54321,"jeffreys",1000,NULL,NULL,NULL,NULL,NULL,testinterim=1 )
fit<-with(data= as.mids(impdatasetMARnoDnoBase), expr = lm(fev.12~treat+base))
if(!require(mice)) install.packages('mice')
library("mice")
fit<-with(data= as.mids(impdatasetMARnoDnoBase), expr = lm(fev.12~treat+base))
summary(pool(fit))
varlist <- c("fev.2","fev.4","fev.8","fev.12");
analyselist(5333,impdatasetMARnoDnoBase,varlist)
analyselist(5051,impdatasetMARnoDnoBase,varlist)
analyselist(5115,impdatasetMARnoDnoBase,varlist)
analyselist(5017,impdatasetMARnoDnoBase,varlist)
impdatasetMARMARnoDnoBase<-mimix("asthma",c("base"),"fev","treat","id","time",M=1000,2,"MAR",54321,"jeffreys",1000,NULL,NULL,NULL,NULL,NULL,testinterim=1 )
fit<-with(data= as.mids(impdatasetMARMARnoDnoBase), expr = lm(fev.12~treat+base))
summary(pool(fit))
analyselist(5333,impdatasetMARMARnoDnoBase,varlist)
analyselist(5051,impdatasetMARMARnoDnoBase,varlist)
analyselist(5115,impdatasetMARMARnoDnoBase,varlist)
impdatasetMARCIRnoDnoBase<-mimix("asthma",c("base"),"fev","treat","id","time",M=1000,2,"CIR",54321,"jeffreys",1000,NULL,NULL,NULL,NULL,NULL,testinterim=1 )
fit<-with(data= as.mids(impdatasetMARCIRnoDnoBase), expr = lm(fev.12~treat+base))
summary(pool(fit))
varlist <- c("fev.2","fev.4","fev.8","fev.12");
analyselist(5333,impdatasetMARCIRnoDnoBase,varlist)
analyselist(5051,impdatasetMARCIRnoDnoBase,varlist)
analyselist(5115,impdatasetMARCIRnoDnoBase,varlist)
fit<-with(data= as.mids(impdatasetMARCIRnoDnoBase), expr = lm(fev.12~treat+base))
summary(pool(fit))
varlist <- c("fev.2","fev.4","fev.8","fev.12");
analyselist(5333,impdatasetMARCIRnoDnoBase,varlist)
analyselist(5051,impdatasetMARCIRnoDnoBase,varlist)
analyselist(5115,impdatasetMARCIRnoDnoBase,varlist)
fit<-with(data= as.mids(impdatasetMARMARnoDnoBase), expr = lm(fev.12~treat+base))
summary(pool(fit))
varlist <- c("fev.2","fev.4","fev.8","fev.12");
analyselist(5333,impdatasetMARMARnoDnoBase,varlist)
analyselist(5051,impdatasetMARMARnoDnoBase,varlist)
analyselist(5115,impdatasetMARMARnoDnoBase,varlist)
analyselist(5017,impdatasetMARMARnoDnoBase,varlist)
analyselist(5059,impdatasetMARMARnoDnoBase,varlist)
analyselist(5017,impdatasetMARCIRnoDnoBase,varlist)
