else if (method == 3 ) {
# changed saving the result into  just the param file, list of 2 so can use list index here
#treatmnets are 1.. M then M+1 ..2M .. etc
mata_means_trt <- paramBiglist[[M*(trtgpindex-1)+m]][1]
mata_means_ref <- paramBiglist[[M*(referindex-1)+m]][1]
#browser(text="pass2method")
# below causes error after using >1 covars and mata_nonmiss has covar.1, not proper covar names
#    browser(text="3112")
# mata_nonmiss and mata_miss toolage in acupuncture data
# repetition of head_base ,the covariate !
mata_means_t <-lapply(mata_means_trt,FUN = function(x) x*mata_nonmiss)
#mata_means_t <- unlist(mata_means_trt)*mata_nonmiss
# print(paste0("mata_means_trt, mata_nonmiss= ",mata_means_trt,mata_miss))
mata_means_r <-lapply(mata_means_ref,FUN = function(x) x*mata_miss)
#mata_means_r <- unlist(mata_means_ref)*mata_miss
# so when all missing  1,1,1, ... then all contributing comes from reference means
mata_means <- unlist(mata_means_r)+unlist(mata_means_t)
#try this 11/04
mata_means<-(as.matrix(t(mata_means)))
# and preserve names
# 11/04 colnames(mata_means) <-  colnames(mata_means_t[[1]])
#replicate to number of rows defined by X1
#mata_means<-mata_means[rep(seq(nrow(mata_means)),each=mg$X1[i]),]
############# SIGMA is from paramsigma  the reference group ################
# do we ever  use SigmaTrt !!?? in j2r?
# answer is ??, need to use SigmaTrt for the predeviation observations, ie up to where they go missing
# only after they go missing (trailing missing) need to use the SigmaRef
#9/3/20
SigmaRefer <- paramBiglist[[M*(referindex-1)+m]][2]
#SigmaRefer <- paramBiglist[[M*(referindex-1)+m]][2]
#SigmaRefer <- get(paste0("paramBiglist",refer,m))[2]
Sigmatrt <- paramBiglist[[M*(trtgpindex-1)+m]][2]
# note use of [[1]] as is matrix rathe than list,
S11 <-SigmaRefer[[1]][c_mata_nonmiss,c_mata_nonmiss]
# causes non-def error in conds
#to ensure rows and cols as should reflect their stucture use matrix
S12 <-matrix(SigmaRefer[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss))
S22 <-SigmaRefer[[1]][c_mata_miss,c_mata_miss]
} #method
# 'CR'
else if (method==2) {
# no need to use Sigmatrt here
mata_means <- paramBiglist[[M*(referindex-1)+m]][1]
#mata_means <- get(paste0("param",refer,m))[1]
# convert from list to matrix
mata_means <- mata_means[[1]]
SigmaRefer <- paramBiglist[[M*(referindex-1)+m]][2]
S11 <-SigmaRefer[[1]][c_mata_nonmiss,c_mata_nonmiss]
S12 <-matrix(SigmaRefer[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss) )
S22 <-SigmaRefer[[1]][c_mata_miss,c_mata_miss]
#Sigma<-SigmaRefer
}
# 'CIR'
else if (method==4)
{
# need to use Sigmatrt as in j2r
# pre-deviating use mean of trt gp up to last obs time bfore deviating, post-deviating use mean from ref grp
# put equiv to mimix
#mata_Means <- get(paste0("param",trtgp,m))[1]
mata_Means <- paramBiglist[[M*(trtgpindex-1)+m]][1]
# convert from list to matrix
mata_Means <- mata_Means[[1]]
#mata_Means <-  get(paste0("parambeta",trtgp,m))
#MeansC <-  get(paste0("param",refer,m))[1]
MeansC <-  paramBiglist[[M*(referindex-1)+m]][1]
#might be better to copy mimix algol
mata_means<-CIR_loop(c_mata_miss,mata_Means,MeansC)
#returns mata_means as single row
# then duplicate over patt rows
#replicate to number of rows defined by X1
# mata_means<-mata_means[rep(seq(nrow(mata_means)),each=mg$X1[i]),]
#SigmaRefer <- get(paste0("paramsigma",refer,m))
SigmaRefer <- paramBiglist[[M*(referindex-1)+m]][2]
# when reading in Stata sigmas
S11 <-SigmaRefer[[1]][c_mata_nonmiss,c_mata_nonmiss]
S12 <-matrix(SigmaRefer[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss))
S22 <-SigmaRefer[[1]][c_mata_miss,c_mata_miss]
# Sigma<- SigmaRefer
}
# 'LMCF'
else if (method==5) {
#browser(text="0602")
#mata_Means <-  get(paste0("param",trtgp,m))[1]
mata_Means <- paramBiglist[[M*(trtgpindex-1)+m]][1]
# convert from list to matrix
mata_Means <- mata_Means[[1]]
# no ref MeansC <- mata_means_ref
mata_means<-LMCF_loop(c_mata_miss,mata_Means)
#mata_means<-mata_means[rep(seq(nrow(mata_means)),each=mg$X1[i]),]
#Sigmatrt <- get(paste0("param",trtgp,m))[2]
Sigmatrt <- paramBiglist[[M*(trtgpindex-1)+m]][2]
# when reading in Stata sigmas
S11 <-Sigmatrt[[1]][c_mata_nonmiss,c_mata_nonmiss]
S12 <-matrix(Sigmatrt[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss))
S22 <-Sigmatrt[[1]][c_mata_miss,c_mata_miss]
#   Sigma<- Sigmatrt
}  #if meth=5
# causal method uses same matrices as CIR with K parameter
else if (method==6)  {
mata_Means <- paramBiglist[[M*(trtgpindex-1)+m]][1]
# convert from list to matrix
mata_Means <- mata_Means[[1]]
#mata_Means <-  get(paste0("parambeta",trtgp,m))
#MeansC <-  get(paste0("param",refer,m))[1]
MeansC <-  paramBiglist[[M*(referindex-1)+m]][1]
#put Kd tempval
#Kd =0 eq0iv to J2R?
#Kd =1 equiv to CIR
#Kd<-0.8
#10/08/20
#browser(text="1301")
mata_means<-Causal_loop(c_mata_miss,mata_Means,MeansC,K0,K1)
#  browser()
#this temporary  for test purposes until algo decided upon
SigmaRefer <- paramBiglist[[M*(referindex-1)+m]][2]
# when reading in Stata sigmas
S11 <-SigmaRefer[[1]][c_mata_nonmiss,c_mata_nonmiss]
S12 <-matrix(SigmaRefer[[1]][c_mata_nonmiss,c_mata_miss],nrow=length(c_mata_nonmiss))
S22 <-SigmaRefer[[1]][c_mata_miss,c_mata_miss]
#10/08/20
#Sigma<- SigmaRefer
}
############# individual analysis #########################
}
#else if(!is.null(methodindiv[1]))
else if (flag_indiv==1) {
# call function for  indiv
indparamlist  <- ifmethodindiv(methodvar,referencevar,mg,m,M,paramBiglist,i,treatvar,c_mata_nonmiss,c_mata_miss,mata_miss,mata_nonmiss,K0,K1)
mata_means<- indparamlist[[1]]
Sigma <- indparamlist[[2]]
}
# loop still open for row(mg)
###################### MNAR IMPUTATION ################
# need insert routine when ALL missing values
# else
###################### MNAR IMPUTATION ################
#make sure these are single row vectors! as mistake in LMCF but have to be duplicate rows so add ,s
#and move after dup fun
# need to repictae mata_means to same numbe rrows as data pattern group
# causing problems replace with simpler
mata_means<-mata_means[rep(seq_len(nrow(mata_means)),each=mg$cases[i]),]
# mata_means<- do.call("rbind",replicate(mg[i,"cases"],mata_means,simplify=FALSE))
#perhaps put zeros in ? to make sure same length??
if (!is.null(nrow(mata_means)) )  {
m1 <- mata_means[,c_mata_nonmiss]
m2 <- mata_means[,c_mata_miss]
} else {
m1 <- mata_means[c_mata_nonmiss]
m2 <- mata_means[c_mata_miss]
}
#then mata_obs is the sequential selection of rows according to the mimix_group variable X1 values
#need a counter to accumulate j  - easiest way is to ceate a cumulstive col in mimix_group
j <- mg[i,"cases"]
#for debug
#print(paste0(" count in patt = ", j))
k <- mg[i,"cumcases"]
startrow <-(k-j+1)
stoprow  <-(k)
#raw1 <- mata_obs[, c_mata_nonmiss]
# preraw <- mata_Obs[c(startrow:stoprow),2:ncol(mata_Obs)]
# drop id  cols from raw data
preraw <-(mata_Obs[c(startrow:stoprow),!(names(mata_Obs) %in% c(idvar))])
raw1 <- preraw[,c_mata_nonmiss]
##### try inserting routine for all missing values here NOt really necessary!! ### 20/1/20 #####
## when all missing data, the length of c_mata_nonmiss must exclude the no. of covariates
## temporary fix set as 1, ie no. of covars 20/01/20
# nOTE think no observed data includes no base line as well?
# all missing ? didnt think we did ths scenario, ie base depvar always complete?
if (length(c_mata_nonmiss)==0)  {
## routine copied from mimix line 1229
# change 9/5/20 becaus error list obj cannot be coerced to double
#0401 U <- chol(Sigma[[1]])
# replaced this with S22 because S11 S12 have 0 values when so try
U <- chol(S22)
# generate inverse normal, same as used below
#for debug 20/01
#   print(paste0('mg[i,X1] =',mg[i,"X1"],' miss_count= ',miss_count))
miss_count<-sum(mata_miss)
Z <- stats::qnorm(matrix(stats::runif( mg[i,"cases"]* miss_count,0,1),mg[i,"cases"],miss_count))
# raw and m1 null fields so hut use m2
meanval = as.matrix(m2)
mata_y1 = meanval+Z%*%(U)
#set dimensions mata_new to mata_y1
#define new matrix from observed,  id column  (the last)
mata_new <- preraw
# mata_new has to be already defined
mata_new[,c_mata_miss] <- (mata_y1)
GI <- array(data=mg[i,treatvar],dim=c(mg[i,"cases"],1))
#II  no imputations
II <- array(data=m,dim=c(mg[i,"cases"],1))
# SNO just id col
# change 1012
#SNO <- mata_Obs[c(startrow:stoprow),1]
SNO <- mata_Obs[c(startrow:stoprow),".id"]
mata_new=cbind(GI,II,mata_new,SNO)
mata_all_newlist[[m_mg_iter]]=mata_new
# 9/5/20 inser else here
} else {
#so S12 must be declare as a matrix ! as number otherwise is class number
#try transpose as was failing compatible error
#note y must have same no rows as Q
#solve Qx=y
#t_mimix =cholsolve(Q=mS11,y=(mS12))
#tryig solve instead ax=b
t_mimix=solve(S11,S12)
conds <-  S22-t(S12)%*%t_mimix
#
#meanval = as.matrix(m2) + as.matrix(raw1 - m1)%*%as.matrix(t_mimix)
# below for CR but need checks work with J2R
# need edit m2 as errormsg "data frame with 0 columns and 1 row"
# 9/3/20
#browser() the else condition not works ,m2 needs matrix
## important calculation to CHECK !!!
#depends whether meth or methodindiv used
#really this needs to be independent of which merh used
# if (meth=='J2R')
#  if  (mg[i,methodindiv[1]] == 3) {
#{  1*1 MATRIX ?
# } else if (mg[i,methodindiv[1]] == 4)   {
# m2 careful as matrix needs to be vertical , test change 17/03
# this works for accupuncture data but not asthma, because when one patient raw daa is 1 by n matrix so m2 needs to be horizontal, ie not a matrix
#19/03  11/04 works for CR but then not for J2R for 5333 patt=7 one patient
if (mg[i,"cases"] == 1) {
meanval = (m2) + as.matrix(raw1 - m1)%*%as.matrix(t_mimix)
}  else {
meanval = as.matrix(m2) + (as.matrix(raw1 - m1)%*%as.matrix(t_mimix))
}
#24/02browser()
U <- chol(conds)
# mg[i,cases] is equiv to Stata counter, miss_count is no. of missing, so
miss_count=rowSums(mata_miss)
# gen erate inverse normal
Z<-stats::qnorm(matrix(stats::runif( mg[i,"cases"]* miss_count,0,1),mg[i,"cases"],miss_count))
# check same input parameters for inverse norm gen as in stata
#for debug 20/01
#  print(paste0('mg[i,X1] =',mg[i,"X1"],' miss_count= ',miss_count))
#mata_y1 = meanval+Z%*%t(U)  14/01/20 try without transpose because Stata Cholesky lower tri, R upper (or vice versa)
mata_y1 = meanval+Z%*%(U)
#define new matrix from observed,  id column  (the last)
mata_new <- preraw
# assigning the columns where the missing values
# was nct (as in stata) = no ntimes + ncovar
# so if no missing then just copy full values into mata_new columns
#if(length(c_mata_miss)==0 ) { mata_new[,c(1:length(tst2))] <- mata_Obs[,c(2:length(tst2))]
if(length(c_mata_miss)==0 ) { mata_new[,c(1:length(tst2))] <- preraw[,c(1:length(tst2))]
}else
{
mata_new[,c_mata_miss] <- mata_y1
}
# if(length(c_mata_miss)!=0 )
#save U,Z for imp(m) and patt(i)
# this worked for Z
#assuming this  from Stata if "`interim'"==""{
# SNO just id col
# chg 1012SNO <- mata_Obs[c(startrow:stoprow),1]
SNO <- mata_Obs[c(startrow:stoprow),".id"]
#SNO <- mata_ObsX[,ncol(mata_Obs)]
# GI treatment grp column 1 (here),II imputation number col, mata_new matrix then SNO is id col.
GI <- array(data=mg[i,1],dim=c(mg[i,"cases"],1))
#II  no imputations
II <- array(data=m,dim=c(mg[i,"cases"],1))
#doesnt need SNO, as id already in
#mata_new<-cbind(GI,II,mata_new,SNO)
#this works but bette to pre initialise data structure outsidr loop
mata_new<-cbind(GI,II,mata_new,SNO)
#assume delta to be used if specified in input argument
if (length(delta != 0) ) {
# browser()
# reset ncovar_i and create dlag if null] browser(text="1612")
# browser(text="1712")
ncovar_i<-length(covar)
if (is.null(dlag)) {
dlag <- rep(1,length(delta))
}
mata_new <-  AddDelta(tst2,  ncovar_i,mata_new,delta,dlag)
# mata_new <-  AddDelta(tst2,  ncovar_i,mata_new,delta,dlag,Imp_Interims_0)
}
mata_all_newlist[[m_mg_iter]]=mata_new
#mata_all_new<-rbind(mata_all_new,mata_new)
#mata_all_new<- na.omit(mata_all_new)
#stata equilv \ is row bind NOt cbind!!?
#9/5/20 end else c_mata_nonmiss ==0 here
}
} # ( m in  1:M) so insert delta module just before this
} #for row[mg]
# check for interim 11/11
# browser()
} #for M StOP HERE!!
# browser(text="passtoloop")
#browser(text="1801")
impdataset<-getimpdatasets(list(mata_all_newlist,mg,M,method))
# but need to adjust orig data set to set interims back to missing
# get .imp=0 's
assign(paste0("Imp_Interims_",0),subset(as.matrix(Imp_Interims[Imp_Interims$.imp==0,])))
# find depvar vars  cols
ImpInters <-    get(paste0("Imp_Interims_",0))
# note keep .imp so can use as match with impdaset and also presreve same col pos
# browser(text="1112 treat? ")
colnames(ImpInters)[colnames(ImpInters)==treatvar]<-"treat"
test_Imp <- subset(ImpInters,select=-c(patt,treat))
#df1<-as.data.frame(mata_Obs)
test_Imp<-as.data.frame(test_Imp)
depcolsf<- grep(paste0(depvar),names(impdataset))
# assume thes coorespnd with interim lookup ! prob ned a check here!!
for ( pos in 1:length(depcolsf)) {
#if (impdataset$.imp==0 )
#impdataset[,depcolsf[pos]][match(test_Imp$.id,impdataset$.id)]<-test_Imp[,depcolsf[pos]]
impdataset[,depcolsf[pos]][match(paste(test_Imp$.id,test_Imp$.imp),paste(impdataset$.id,impdataset$.imp))]<-test_Imp[,depcolsf[pos]]
}
# moved from getimpdatasets fun
cat(paste0("\n\nNumber of final missing values = ", sum(is.na(subset(impdataset,impdataset$.imp>0)))))
#cat(paste("\ntest pass2 in runmimx"))
return(impdataset)
}
#' @title fills missing interims distinguishing from post-discontinuation
#' @description fills missing interims distinguishing from post-discontinuation
#' @details checks methodindiv not null
#' @param impdata the data with missing values
#' @param interims the interim cases with estimated MAR values
#' @param Mimp the number of imputations specified , ie M total imputsations
#' @return list of 1st data set with interims imputed plus M interim cases of each interim case to be matche in 2nd pass
fillinterims<- function(impdata,interims,Mimp=M ) {
#2811
#0312 browser(text="not means")
#2711browser(text="find estimate over all imps")
#convert to data.table
#2611 browser(text="fillinterims")
impMarint_dt <- data.table::as.data.table(impdata)
interims_dt <- data.table::as.data.table(interims)
#browser(text="2402")
data.table::setkey(impMarint_dt,.id)
data.table::setkey(interims_dt,V1)
#merge
#(impMarint_dt[interims_dt])
# convert to 0, 1 =missing
# sapply(impMarint_dt[interims_dt],function(x) ifelse(is.na(x) ,1,0) )
# exclude last non-response cols
test10<-sapply(impMarint_dt[interims_dt],function(x) ifelse(is.na(x) ,1,0) )
test10x<-test10[,c(1:(ncol(test10)-3))]
# find max non-missing
lastvalid<-apply(test10x,1, function(x) max(which(x==0))  )
#merge back
test1611<-cbind(impMarint_dt[interims_dt],lastvalid)
#if (test1611$.id == shift(test1611$.id,-1) ) {
# over many imps, find mean value by interims for imp>0 then combineback to
# have .imp0 and mean row
# 2811 no need for means now just need to send  M'th values of fev 2-fev12
#test2611 <-setDT(as.data.frame(subset(test1611,.imp>0)))[,lapply(.SD,mean),by= .id,]
#2911 test2611 <- setDT(as.data.frame(subset(test1611,.imp>0)))[,lapply(.SD,mean),by= .(id,imp)]
# find.imp0's  test3611[order(test3611$.id),][order(assign(paste0("test1611imp",val),subset(test1611,.imp==val))$.id),]
test1611imp0<- subset(test1611,.imp==0)
#declare void matrix for rbinding
test1611impD <- test1611imp0
for (val in 1:Mimp) {
rbind(assign(paste0("test1611imp",val),subset(test1611,.imp==val | .imp==0)),test1611imp0)
test1611impx<-as.matrix(get(paste0("test1611imp",val )))
for  (r in seq(from =1 , to= nrow(test1611impx)-1,by=2)) {
for (j in 2:(ncol(test1611impx)-3)) {
# if element na and must be bfore lastvalid non missing
if (is.na(test1611impx[r,j]) & (j<test1611impx[r,ncol(test1611impx)]) ) {
# then shift value from below row
test1611impx[r,j] = test1611impx[r+1,j]
}
}
}
# keep imp0's and recode non imp0 to imp (m) number
test1611impxm <-  subset(test1611impx,test1611impx[,".imp"]==0)
test1611impxm[,".imp"]<-val
# build up ovder M imps
test1611impD <- rbind(test1611impD,test1611impxm)
}
# so need to insert into original unimputed data set for each imputstion and process each dat set into the 2nd pass
# take lastvalid off
#test1611impDl<-test1611impD[,-ncol(test1611impD)]
test1611impD$lastvalid <-NULL
#extract m'th imp
test1611impD02<-as.matrix(test1611impD[test1611impD$.imp==2,])
#test1611impD02<-as.matrix(test1611impDl[test1611impDl[,1]==2,])
impMarint <- as.matrix(impMarint_dt)
impMarint0<-as.matrix(impMarint_dt[impMarint_dt$.imp==0,])
# this works well (but MUST Be MATRICES)
#212 impMarint0[impMarint0[,'.id'] %in% test1611impD02[,'.id'], ] <- test1611impD02
# so .imp=0 now has interims filled and can be treated as original data
return(list(impMarint0,test1611impD))
}
# mimix: A package porting the Stata mimix command
#
# The mimix package provides the functionality of the Stata package plus
# delta and causal methods
#
# @section Comparison with Stata:
# details here ...
#
# @section Comparison with SAS:
# details here ...
#
#
# @docType package
# @name mimix
#NULL
#> NULL
mimix("asthma",c("base"),"fev","treat","id","time",5,1,"J2R",,,,,,,,,1,0.5,)
mimix(data=asthma,covar=c(base),depvar=fev,treatvar=treat,idvar=id,timevar=time,method="J2R",reference=1,M=5,seed=54321)
devtools::document()
library(mimix)
devtools::document()
library(mimix)
#' Sample data: asthma trial
#' A data set containing  asthma trial data as used in the Stata mimix help file
#' The primary outcome variable is fev,  measured at 2,4,8,12 weeks
#' @format A data frame containing 732 rows and 5 columns
#'   \describe{
#'   \item{id}{patient identifier}{}
#'   \item{time}{}
#'   \item{treat}{}
#'   \item{base}{covariate}{}
#'   \item{fev}{dependent variable}{}
#'   }
#' @examples
#' \dontrun{
#' impJ2Rridge<-(mimix(data=asthma,covar=c("base"),depvar=fev,treatvar=treat,idvar=id,timevar=time,
#'     method="J2R",reference=1,delta=c(0.5,0.5,1,1 ),M=5,seed=101,prior=ridge,burnin=1000)
#' library(mice)
#' fit<-with(data= as.mids(impJ2Rridge),lm(fev.12~treat))
#' summary(pool(fit))
#' }
"asthma"
#' Sample data: antidepressant trial
#' A data set containing antidepressant trial data as described in paper by White, Royes, Best (2019)
#' The primary outcome is HAMD17.TOTAL measured at visit number 4,5,6,7.
#' @format  A data frame containing 688 rows and 14 columns
#'  \describe{
#'  \item{PATIENT.NUMBER}{}
#'  \item{HAMA.TOTAL}{}
#'  \item{PGI_IMPROVEMENT}{}
#'  \item{VISIT...VISIT.3.DATE}{}
#'  \item{VISIT.NUMBER}{}
#'  \item{TREATMENT.NAME}{}
#'  \item{PATIENT.SEX}{}
#'  \item{POOLED.INVESTIGATOR}{}
#'  \item{basval}{covariate}{}
#'  \item{HAMD17.TOTAL}{dependent variable}{}
#'  \item{change}{}
#'  \item{miss_flag}{}
#'  \item{methodcol}{individual-specific method}{}
#'  \item{referencecol}{individual-specific reference arm}{}
#'  }
#'  @examples
#'  \dontrun{
#'  impIndiv <- mimix(data=antidepressant,covar=c("basval","PATIENT.SEX"),depvar=HAMD17.TOTAL,treatvar=TREATMENT.NAME,idvar=PATIENT.NUMBER,
#'        timevar=VISIT.NUMBER,methodvar="methodcol",referencevar="referencecol",M=5,seed=54321)
#'  library(mice)
#'  fit<-with(data= as.mids(impantiIndivDt),lm(HAMD17.TOTAL.7~TREATMENT.NAME+basval+PATIENT.SEX))
#'  summary(pool(fit))
#'  }
"antidepressant"
#' Sample data: acupuncture trial
#' A data set containing results of a randomised, double-blind, parallel-group comparing active treatment with placebo
#' The primary outcome is head, measured at time 3 and 12
#' @format A data frame with 802 rows and 11 columns
#'  \describe{
#'  \item{id}{patient identifier}{}
#'  \item{time}{}
#'  \item{age}{}
#'  \item{sex}{}
#'  \item{migraine}{}
#'  \item{chronicity}{}
#'  \item{practice_id}{}
#'  \item{treat}{}
#'  \item{head_base}{covariate}{}
#'  \item{head}{dependent variable }{}
#'  \item{withdrawal_reason}{}
#'  }
#'  @examples
#'  \dontrun{
#'  impCausalref1 <- mimix(data=acupuncture,covar=c("head_base","sex"),depvar=head,treatvar=treat,idvar=id,timevar=time,
#'        method=Causal,reference=1,K0=1,K1=0.5,M=5,seed=54321)
#'  library(mice)
#'  fit<-with(as.mids(impCausalref1), lm(head.12~treat+head_base+sex))
#'  summary(pool(fit))
#'  }
#'
"acupuncture"
# eample output file
# impdataCausal.
#
#  A dataset containing imputed values obtained from mimix on asthma data
#
#   @format A data frame with 1098 rows and 9 columns
#   \describe{
#   \item{.imp}{imputation number}
#   \item{base}{covariate}
#   \item{fev.2}{response at time 2}
#   \item{fev.4}{response at time 4}
#   \item{fev.8}{response at time 8}
#   \item{fev.12}{response at time 12}
#   \item{patt}{missing data pattern}
#   \item{treat}{treatment group}
#   \item{.id}{case id}
#  }
# "mpdataCausal"
devtools::document()
library(mimix)
`rm(list = c("AddDelta", "analyselist", "Causal_loop", "CIR_loop", "fillinterims", "getimpdatasets", "ifmethodindiv", "LMCF_loop", "mimix", "pass2Loop", "preprodata", "preproIndivdata"))
)
rm(list = c("AddDelta", "analyselist", "Causal_loop", "CIR_loop", "fillinterims", "getimpdatasets", "ifmethodindiv", "LMCF_loop", "mimix", "pass2Loop", "preprodata", "preproIndivdata"))
devtools::document()
library(mimix)
# check original values unchanged
impantiIndivDt <- mimix(data=antidepressant,covar=c("basval","PATIENT.SEX"),depvar=HAMD17.TOTAL,treatvar=TREATMENT.NAME,idvar=PATIENT.NUMBER,timevar=VISIT.NUMBER,methodvar="methodcol",referencevar="referencecol",M=5,seed=54321)
####################################### acupuncture data ##################################################################
impacupCausal <- mimix(data=acupuncture,covar=c("head_base","sex"),depvar=head,treatvar=treat,idvar=id,timevar=time,method="CIR",reference=1,K0=1,K1=0.5,M=5,seed=54321)
